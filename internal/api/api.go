// Package ApispecOpenhab3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for ConfigDescriptionParameterType.
const (
	ConfigDescriptionParameterTypeBOOLEAN ConfigDescriptionParameterType = "BOOLEAN"

	ConfigDescriptionParameterTypeDECIMAL ConfigDescriptionParameterType = "DECIMAL"

	ConfigDescriptionParameterTypeINTEGER ConfigDescriptionParameterType = "INTEGER"

	ConfigDescriptionParameterTypeTEXT ConfigDescriptionParameterType = "TEXT"
)

// Defines values for ConfigDescriptionParameterDTOType.
const (
	ConfigDescriptionParameterDTOTypeBOOLEAN ConfigDescriptionParameterDTOType = "BOOLEAN"

	ConfigDescriptionParameterDTOTypeDECIMAL ConfigDescriptionParameterDTOType = "DECIMAL"

	ConfigDescriptionParameterDTOTypeINTEGER ConfigDescriptionParameterDTOType = "INTEGER"

	ConfigDescriptionParameterDTOTypeTEXT ConfigDescriptionParameterDTOType = "TEXT"
)

// Defines values for ConfigStatusMessageType.
const (
	ConfigStatusMessageTypeERROR ConfigStatusMessageType = "ERROR"

	ConfigStatusMessageTypeINFORMATION ConfigStatusMessageType = "INFORMATION"

	ConfigStatusMessageTypePENDING ConfigStatusMessageType = "PENDING"

	ConfigStatusMessageTypeWARNING ConfigStatusMessageType = "WARNING"
)

// Defines values for DiscoveryResultDTOFlag.
const (
	DiscoveryResultDTOFlagIGNORED DiscoveryResultDTOFlag = "IGNORED"

	DiscoveryResultDTOFlagNEW DiscoveryResultDTOFlag = "NEW"
)

// Defines values for EnrichedRuleDTOVisibility.
const (
	EnrichedRuleDTOVisibilityEXPERT EnrichedRuleDTOVisibility = "EXPERT"

	EnrichedRuleDTOVisibilityHIDDEN EnrichedRuleDTOVisibility = "HIDDEN"

	EnrichedRuleDTOVisibilityVISIBLE EnrichedRuleDTOVisibility = "VISIBLE"
)

// Defines values for IconSetFormats.
const (
	IconSetFormatsPNG IconSetFormats = "PNG"

	IconSetFormatsSVG IconSetFormats = "SVG"
)

// Defines values for ModuleTypeDTOVisibility.
const (
	ModuleTypeDTOVisibilityEXPERT ModuleTypeDTOVisibility = "EXPERT"

	ModuleTypeDTOVisibilityHIDDEN ModuleTypeDTOVisibility = "HIDDEN"

	ModuleTypeDTOVisibilityVISIBLE ModuleTypeDTOVisibility = "VISIBLE"
)

// Defines values for RuleVisibility.
const (
	RuleVisibilityEXPERT RuleVisibility = "EXPERT"

	RuleVisibilityHIDDEN RuleVisibility = "HIDDEN"

	RuleVisibilityVISIBLE RuleVisibility = "VISIBLE"
)

// Defines values for RuleDTOVisibility.
const (
	RuleDTOVisibilityEXPERT RuleDTOVisibility = "EXPERT"

	RuleDTOVisibilityHIDDEN RuleDTOVisibility = "HIDDEN"

	RuleDTOVisibilityVISIBLE RuleDTOVisibility = "VISIBLE"
)

// Defines values for RuleStatusInfoStatus.
const (
	RuleStatusInfoStatusIDLE RuleStatusInfoStatus = "IDLE"

	RuleStatusInfoStatusINITIALIZING RuleStatusInfoStatus = "INITIALIZING"

	RuleStatusInfoStatusRUNNING RuleStatusInfoStatus = "RUNNING"

	RuleStatusInfoStatusUNINITIALIZED RuleStatusInfoStatus = "UNINITIALIZED"
)

// Defines values for RuleStatusInfoStatusDetail.
const (
	RuleStatusInfoStatusDetailCONFIGURATIONERROR RuleStatusInfoStatusDetail = "CONFIGURATION_ERROR"

	RuleStatusInfoStatusDetailDISABLED RuleStatusInfoStatusDetail = "DISABLED"

	RuleStatusInfoStatusDetailHANDLERINITIALIZINGERROR RuleStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"

	RuleStatusInfoStatusDetailHANDLERMISSINGERROR RuleStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"

	RuleStatusInfoStatusDetailINVALIDRULE RuleStatusInfoStatusDetail = "INVALID_RULE"

	RuleStatusInfoStatusDetailNONE RuleStatusInfoStatusDetail = "NONE"

	RuleStatusInfoStatusDetailTEMPLATEMISSINGERROR RuleStatusInfoStatusDetail = "TEMPLATE_MISSING_ERROR"
)

// Defines values for TemplateVisibility.
const (
	TemplateVisibilityEXPERT TemplateVisibility = "EXPERT"

	TemplateVisibilityHIDDEN TemplateVisibility = "HIDDEN"

	TemplateVisibilityVISIBLE TemplateVisibility = "VISIBLE"
)

// Defines values for ThingStatusInfoStatus.
const (
	ThingStatusInfoStatusINITIALIZING ThingStatusInfoStatus = "INITIALIZING"

	ThingStatusInfoStatusOFFLINE ThingStatusInfoStatus = "OFFLINE"

	ThingStatusInfoStatusONLINE ThingStatusInfoStatus = "ONLINE"

	ThingStatusInfoStatusREMOVED ThingStatusInfoStatus = "REMOVED"

	ThingStatusInfoStatusREMOVING ThingStatusInfoStatus = "REMOVING"

	ThingStatusInfoStatusUNINITIALIZED ThingStatusInfoStatus = "UNINITIALIZED"

	ThingStatusInfoStatusUNKNOWN ThingStatusInfoStatus = "UNKNOWN"
)

// Defines values for ThingStatusInfoStatusDetail.
const (
	ThingStatusInfoStatusDetailBRIDGEOFFLINE ThingStatusInfoStatusDetail = "BRIDGE_OFFLINE"

	ThingStatusInfoStatusDetailBRIDGEUNINITIALIZED ThingStatusInfoStatusDetail = "BRIDGE_UNINITIALIZED"

	ThingStatusInfoStatusDetailCOMMUNICATIONERROR ThingStatusInfoStatusDetail = "COMMUNICATION_ERROR"

	ThingStatusInfoStatusDetailCONFIGURATIONERROR ThingStatusInfoStatusDetail = "CONFIGURATION_ERROR"

	ThingStatusInfoStatusDetailCONFIGURATIONPENDING ThingStatusInfoStatusDetail = "CONFIGURATION_PENDING"

	ThingStatusInfoStatusDetailDISABLED ThingStatusInfoStatusDetail = "DISABLED"

	ThingStatusInfoStatusDetailDUTYCYCLE ThingStatusInfoStatusDetail = "DUTY_CYCLE"

	ThingStatusInfoStatusDetailFIRMWAREUPDATING ThingStatusInfoStatusDetail = "FIRMWARE_UPDATING"

	ThingStatusInfoStatusDetailGONE ThingStatusInfoStatusDetail = "GONE"

	ThingStatusInfoStatusDetailHANDLERCONFIGURATIONPENDING ThingStatusInfoStatusDetail = "HANDLER_CONFIGURATION_PENDING"

	ThingStatusInfoStatusDetailHANDLERINITIALIZINGERROR ThingStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"

	ThingStatusInfoStatusDetailHANDLERMISSINGERROR ThingStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"

	ThingStatusInfoStatusDetailHANDLERREGISTERINGERROR ThingStatusInfoStatusDetail = "HANDLER_REGISTERING_ERROR"

	ThingStatusInfoStatusDetailNONE ThingStatusInfoStatusDetail = "NONE"
)

// Action defines model for Action.
type Action struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Inputs        *Action_Inputs `json:"inputs,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// Action_Inputs defines model for Action.Inputs.
type Action_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ActionDTO defines model for ActionDTO.
type ActionDTO struct {
	Configuration *ActionDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                  `json:"description,omitempty"`
	Id            *string                  `json:"id,omitempty"`
	Inputs        *ActionDTO_Inputs        `json:"inputs,omitempty"`
	Label         *string                  `json:"label,omitempty"`
	Type          *string                  `json:"type,omitempty"`
}

// ActionDTO_Configuration defines model for ActionDTO.Configuration.
type ActionDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ActionDTO_Inputs defines model for ActionDTO.Inputs.
type ActionDTO_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Addon defines model for Addon.
type Addon struct {
	Author               *string           `json:"author,omitempty"`
	BackgroundColor      *string           `json:"backgroundColor,omitempty"`
	ConfigDescriptionURI *string           `json:"configDescriptionURI,omitempty"`
	Connection           *string           `json:"connection,omitempty"`
	ContentType          *string           `json:"contentType,omitempty"`
	Countries            *string           `json:"countries,omitempty"`
	Description          *string           `json:"description,omitempty"`
	DetailedDescription  *string           `json:"detailedDescription,omitempty"`
	Id                   *string           `json:"id,omitempty"`
	ImageLink            *string           `json:"imageLink,omitempty"`
	Installed            *bool             `json:"installed,omitempty"`
	Keywords             *string           `json:"keywords,omitempty"`
	Label                *string           `json:"label,omitempty"`
	License              *string           `json:"license,omitempty"`
	Link                 *string           `json:"link,omitempty"`
	Maturity             *string           `json:"maturity,omitempty"`
	Properties           *Addon_Properties `json:"properties,omitempty"`
	Type                 *string           `json:"type,omitempty"`
	VerifiedAuthor       *bool             `json:"verifiedAuthor,omitempty"`
	Version              *string           `json:"version,omitempty"`
}

// Addon_Properties defines model for Addon.Properties.
type Addon_Properties struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// AddonType defines model for AddonType.
type AddonType struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSinkDTO defines model for AudioSinkDTO.
type AudioSinkDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSourceDTO defines model for AudioSourceDTO.
type AudioSourceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// BindingInfoDTO defines model for BindingInfoDTO.
type BindingInfoDTO struct {
	Author               *string `json:"author,omitempty"`
	ConfigDescriptionURI *string `json:"configDescriptionURI,omitempty"`
	Description          *string `json:"description,omitempty"`
	Id                   *string `json:"id,omitempty"`
	Name                 *string `json:"name,omitempty"`
}

// ChannelDTO defines model for ChannelDTO.
type ChannelDTO struct {
	AutoUpdatePolicy *string                   `json:"autoUpdatePolicy,omitempty"`
	ChannelTypeUID   *string                   `json:"channelTypeUID,omitempty"`
	Configuration    *ChannelDTO_Configuration `json:"configuration,omitempty"`
	DefaultTags      *[]string                 `json:"defaultTags,omitempty"`
	Description      *string                   `json:"description,omitempty"`
	Id               *string                   `json:"id,omitempty"`
	ItemType         *string                   `json:"itemType,omitempty"`
	Kind             *string                   `json:"kind,omitempty"`
	Label            *string                   `json:"label,omitempty"`
	Properties       *ChannelDTO_Properties    `json:"properties,omitempty"`
	Uid              *string                   `json:"uid,omitempty"`
}

// ChannelDTO_Configuration defines model for ChannelDTO.Configuration.
type ChannelDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ChannelDTO_Properties defines model for ChannelDTO.Properties.
type ChannelDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ChannelDefinitionDTO defines model for ChannelDefinitionDTO.
type ChannelDefinitionDTO struct {
	Advanced         *bool                            `json:"advanced,omitempty"`
	Category         *string                          `json:"category,omitempty"`
	Description      *string                          `json:"description,omitempty"`
	Id               *string                          `json:"id,omitempty"`
	Label            *string                          `json:"label,omitempty"`
	Properties       *ChannelDefinitionDTO_Properties `json:"properties,omitempty"`
	StateDescription *StateDescription                `json:"stateDescription,omitempty"`
	Tags             *[]string                        `json:"tags,omitempty"`
	TypeUID          *string                          `json:"typeUID,omitempty"`
}

// ChannelDefinitionDTO_Properties defines model for ChannelDefinitionDTO.Properties.
type ChannelDefinitionDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ChannelGroupDefinitionDTO defines model for ChannelGroupDefinitionDTO.
type ChannelGroupDefinitionDTO struct {
	Channels    *[]ChannelDefinitionDTO `json:"channels,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Label       *string                 `json:"label,omitempty"`
}

// ChannelTypeDTO defines model for ChannelTypeDTO.
type ChannelTypeDTO struct {
	UID                *string                               `json:"UID,omitempty"`
	Advanced           *bool                                 `json:"advanced,omitempty"`
	Category           *string                               `json:"category,omitempty"`
	CommandDescription *CommandDescription                   `json:"commandDescription,omitempty"`
	Description        *string                               `json:"description,omitempty"`
	ItemType           *string                               `json:"itemType,omitempty"`
	Kind               *string                               `json:"kind,omitempty"`
	Label              *string                               `json:"label,omitempty"`
	ParameterGroups    *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters         *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	StateDescription   *StateDescription                     `json:"stateDescription,omitempty"`
	Tags               *[]string                             `json:"tags,omitempty"`
}

// CommandDescription defines model for CommandDescription.
type CommandDescription struct {
	CommandOptions *[]CommandOption `json:"commandOptions,omitempty"`
}

// CommandOption defines model for CommandOption.
type CommandOption struct {
	Command *string `json:"command,omitempty"`
	Label   *string `json:"label,omitempty"`
}

// Condition defines model for Condition.
type Condition struct {
	Configuration *Configuration    `json:"configuration,omitempty"`
	Description   *string           `json:"description,omitempty"`
	Id            *string           `json:"id,omitempty"`
	Inputs        *Condition_Inputs `json:"inputs,omitempty"`
	Label         *string           `json:"label,omitempty"`
	TypeUID       *string           `json:"typeUID,omitempty"`
}

// Condition_Inputs defines model for Condition.Inputs.
type Condition_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ConditionDTO defines model for ConditionDTO.
type ConditionDTO struct {
	Configuration *ConditionDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                     `json:"description,omitempty"`
	Id            *string                     `json:"id,omitempty"`
	Inputs        *ConditionDTO_Inputs        `json:"inputs,omitempty"`
	Label         *string                     `json:"label,omitempty"`
	Type          *string                     `json:"type,omitempty"`
}

// ConditionDTO_Configuration defines model for ConditionDTO.Configuration.
type ConditionDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ConditionDTO_Inputs defines model for ConditionDTO.Inputs.
type ConditionDTO_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ConfigDescriptionDTO defines model for ConfigDescriptionDTO.
type ConfigDescriptionDTO struct {
	ParameterGroups *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters      *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	Uri             *string                               `json:"uri,omitempty"`
}

// ConfigDescriptionParameter defines model for ConfigDescriptionParameter.
type ConfigDescriptionParameter struct {
	Advanced       *bool                           `json:"advanced,omitempty"`
	Context        *string                         `json:"context,omitempty"`
	Default        *string                         `json:"default,omitempty"`
	Description    *string                         `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteria               `json:"filterCriteria,omitempty"`
	GroupName      *string                         `json:"groupName,omitempty"`
	Label          *string                         `json:"label,omitempty"`
	LimitToOptions *bool                           `json:"limitToOptions,omitempty"`
	Maximum        *float32                        `json:"maximum,omitempty"`
	Minimum        *float32                        `json:"minimum,omitempty"`
	Multiple       *bool                           `json:"multiple,omitempty"`
	MultipleLimit  *int32                          `json:"multipleLimit,omitempty"`
	Name           *string                         `json:"name,omitempty"`
	Options        *[]ParameterOption              `json:"options,omitempty"`
	Pattern        *string                         `json:"pattern,omitempty"`
	ReadOnly       *bool                           `json:"readOnly,omitempty"`
	Required       *bool                           `json:"required,omitempty"`
	StepSize       *float32                        `json:"stepSize,omitempty"`
	Type           *ConfigDescriptionParameterType `json:"type,omitempty"`
	Unit           *string                         `json:"unit,omitempty"`
	UnitLabel      *string                         `json:"unitLabel,omitempty"`
	Verifyable     *bool                           `json:"verifyable,omitempty"`
}

// ConfigDescriptionParameterType defines model for ConfigDescriptionParameter.Type.
type ConfigDescriptionParameterType string

// ConfigDescriptionParameterDTO defines model for ConfigDescriptionParameterDTO.
type ConfigDescriptionParameterDTO struct {
	Advanced       *bool                              `json:"advanced,omitempty"`
	Context        *string                            `json:"context,omitempty"`
	DefaultValue   *string                            `json:"defaultValue,omitempty"`
	Description    *string                            `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteriaDTO               `json:"filterCriteria,omitempty"`
	GroupName      *string                            `json:"groupName,omitempty"`
	Label          *string                            `json:"label,omitempty"`
	LimitToOptions *bool                              `json:"limitToOptions,omitempty"`
	Max            *float32                           `json:"max,omitempty"`
	Min            *float32                           `json:"min,omitempty"`
	Multiple       *bool                              `json:"multiple,omitempty"`
	MultipleLimit  *int32                             `json:"multipleLimit,omitempty"`
	Name           *string                            `json:"name,omitempty"`
	Options        *[]ParameterOptionDTO              `json:"options,omitempty"`
	Pattern        *string                            `json:"pattern,omitempty"`
	ReadOnly       *bool                              `json:"readOnly,omitempty"`
	Required       *bool                              `json:"required,omitempty"`
	Stepsize       *float32                           `json:"stepsize,omitempty"`
	Type           *ConfigDescriptionParameterDTOType `json:"type,omitempty"`
	Unit           *string                            `json:"unit,omitempty"`
	UnitLabel      *string                            `json:"unitLabel,omitempty"`
	Verify         *bool                              `json:"verify,omitempty"`
}

// ConfigDescriptionParameterDTOType defines model for ConfigDescriptionParameterDTO.Type.
type ConfigDescriptionParameterDTOType string

// ConfigDescriptionParameterGroupDTO defines model for ConfigDescriptionParameterGroupDTO.
type ConfigDescriptionParameterGroupDTO struct {
	Advanced    *bool   `json:"advanced,omitempty"`
	Context     *string `json:"context,omitempty"`
	Description *string `json:"description,omitempty"`
	Label       *string `json:"label,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ConfigStatusMessage defines model for ConfigStatusMessage.
type ConfigStatusMessage struct {
	Message       *string                  `json:"message,omitempty"`
	ParameterName *string                  `json:"parameterName,omitempty"`
	StatusCode    *int32                   `json:"statusCode,omitempty"`
	Type          *ConfigStatusMessageType `json:"type,omitempty"`
}

// ConfigStatusMessageType defines model for ConfigStatusMessage.Type.
type ConfigStatusMessageType string

// ConfigurableServiceDTO defines model for ConfigurableServiceDTO.
type ConfigurableServiceDTO struct {
	Category             *string `json:"category,omitempty"`
	ConfigDescriptionURI *string `json:"configDescriptionURI,omitempty"`
	Id                   *string `json:"id,omitempty"`
	Label                *string `json:"label,omitempty"`
	Multiple             *bool   `json:"multiple,omitempty"`
}

// Configuration defines model for Configuration.
type Configuration struct {
	Properties *Configuration_Properties `json:"properties,omitempty"`
}

// Configuration_Properties defines model for Configuration.Properties.
type Configuration_Properties struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// DiscoveryResultDTO defines model for DiscoveryResultDTO.
type DiscoveryResultDTO struct {
	BridgeUID              *string                        `json:"bridgeUID,omitempty"`
	Flag                   *DiscoveryResultDTOFlag        `json:"flag,omitempty"`
	Label                  *string                        `json:"label,omitempty"`
	Properties             *DiscoveryResultDTO_Properties `json:"properties,omitempty"`
	RepresentationProperty *string                        `json:"representationProperty,omitempty"`
	ThingTypeUID           *string                        `json:"thingTypeUID,omitempty"`
	ThingUID               *string                        `json:"thingUID,omitempty"`
}

// DiscoveryResultDTOFlag defines model for DiscoveryResultDTO.Flag.
type DiscoveryResultDTOFlag string

// DiscoveryResultDTO_Properties defines model for DiscoveryResultDTO.Properties.
type DiscoveryResultDTO_Properties struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedChannelDTO defines model for EnrichedChannelDTO.
type EnrichedChannelDTO struct {
	AutoUpdatePolicy *string                           `json:"autoUpdatePolicy,omitempty"`
	ChannelTypeUID   *string                           `json:"channelTypeUID,omitempty"`
	Configuration    *EnrichedChannelDTO_Configuration `json:"configuration,omitempty"`
	DefaultTags      *[]string                         `json:"defaultTags,omitempty"`
	Description      *string                           `json:"description,omitempty"`
	Id               *string                           `json:"id,omitempty"`
	ItemType         *string                           `json:"itemType,omitempty"`
	Kind             *string                           `json:"kind,omitempty"`
	Label            *string                           `json:"label,omitempty"`
	LinkedItems      *[]string                         `json:"linkedItems,omitempty"`
	Properties       *EnrichedChannelDTO_Properties    `json:"properties,omitempty"`
	Uid              *string                           `json:"uid,omitempty"`
}

// EnrichedChannelDTO_Configuration defines model for EnrichedChannelDTO.Configuration.
type EnrichedChannelDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedChannelDTO_Properties defines model for EnrichedChannelDTO.Properties.
type EnrichedChannelDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// EnrichedItemChannelLinkDTO defines model for EnrichedItemChannelLinkDTO.
type EnrichedItemChannelLinkDTO struct {
	ChannelUID    *string                                   `json:"channelUID,omitempty"`
	Configuration *EnrichedItemChannelLinkDTO_Configuration `json:"configuration,omitempty"`
	Editable      *bool                                     `json:"editable,omitempty"`
	ItemName      *string                                   `json:"itemName,omitempty"`
}

// EnrichedItemChannelLinkDTO_Configuration defines model for EnrichedItemChannelLinkDTO.Configuration.
type EnrichedItemChannelLinkDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedItemDTO defines model for EnrichedItemDTO.
type EnrichedItemDTO struct {
	Category           *string                   `json:"category,omitempty"`
	CommandDescription *CommandDescription       `json:"commandDescription,omitempty"`
	Editable           *bool                     `json:"editable,omitempty"`
	GroupNames         *[]string                 `json:"groupNames,omitempty"`
	Label              *string                   `json:"label,omitempty"`
	Link               *string                   `json:"link,omitempty"`
	Metadata           *EnrichedItemDTO_Metadata `json:"metadata,omitempty"`
	Name               *string                   `json:"name,omitempty"`
	State              *string                   `json:"state,omitempty"`
	StateDescription   *StateDescription         `json:"stateDescription,omitempty"`
	Tags               *[]string                 `json:"tags,omitempty"`
	TransformedState   *string                   `json:"transformedState,omitempty"`
	Type               *string                   `json:"type,omitempty"`
}

// EnrichedItemDTO_Metadata defines model for EnrichedItemDTO.Metadata.
type EnrichedItemDTO_Metadata struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedRuleDTO defines model for EnrichedRuleDTO.
type EnrichedRuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Configuration      *EnrichedRuleDTO_Configuration   `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Editable           *bool                            `json:"editable,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Status             *RuleStatusInfo                  `json:"status,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *EnrichedRuleDTOVisibility       `json:"visibility,omitempty"`
}

// EnrichedRuleDTO_Configuration defines model for EnrichedRuleDTO.Configuration.
type EnrichedRuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedRuleDTOVisibility defines model for EnrichedRuleDTO.Visibility.
type EnrichedRuleDTOVisibility string

// EnrichedThingDTO defines model for EnrichedThingDTO.
type EnrichedThingDTO struct {
	UID            *string                         `json:"UID,omitempty"`
	BridgeUID      *string                         `json:"bridgeUID,omitempty"`
	Channels       *[]EnrichedChannelDTO           `json:"channels,omitempty"`
	Configuration  *EnrichedThingDTO_Configuration `json:"configuration,omitempty"`
	Editable       *bool                           `json:"editable,omitempty"`
	FirmwareStatus *FirmwareStatusDTO              `json:"firmwareStatus,omitempty"`
	Label          *string                         `json:"label,omitempty"`
	Location       *string                         `json:"location,omitempty"`
	Properties     *EnrichedThingDTO_Properties    `json:"properties,omitempty"`
	StatusInfo     *ThingStatusInfo                `json:"statusInfo,omitempty"`
	ThingTypeUID   *string                         `json:"thingTypeUID,omitempty"`
}

// EnrichedThingDTO_Configuration defines model for EnrichedThingDTO.Configuration.
type EnrichedThingDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedThingDTO_Properties defines model for EnrichedThingDTO.Properties.
type EnrichedThingDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// FilterCriteria defines model for FilterCriteria.
type FilterCriteria struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FilterCriteriaDTO defines model for FilterCriteriaDTO.
type FilterCriteriaDTO struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FirmwareDTO defines model for FirmwareDTO.
type FirmwareDTO struct {
	Changelog           *string `json:"changelog,omitempty"`
	Description         *string `json:"description,omitempty"`
	Model               *string `json:"model,omitempty"`
	ModelRestricted     *bool   `json:"modelRestricted,omitempty"`
	PrerequisiteVersion *string `json:"prerequisiteVersion,omitempty"`
	ThingTypeUID        *string `json:"thingTypeUID,omitempty"`
	Vendor              *string `json:"vendor,omitempty"`
	Version             *string `json:"version,omitempty"`
}

// FirmwareStatusDTO defines model for FirmwareStatusDTO.
type FirmwareStatusDTO struct {
	Status           *string `json:"status,omitempty"`
	UpdatableVersion *string `json:"updatableVersion,omitempty"`
}

// GalleryItem defines model for GalleryItem.
type GalleryItem struct {
	Author          *string    `json:"author,omitempty"`
	AuthorAvatarUrl *string    `json:"authorAvatarUrl,omitempty"`
	AuthorName      *string    `json:"authorName,omitempty"`
	CreatedDate     *time.Time `json:"createdDate,omitempty"`
	Description     *string    `json:"description,omitempty"`
	Id              *string    `json:"id,omitempty"`
	ImageUrl        *string    `json:"imageUrl,omitempty"`
	Likes           *int32     `json:"likes,omitempty"`
	Posts           *int32     `json:"posts,omitempty"`
	Readme          *string    `json:"readme,omitempty"`
	Title           *string    `json:"title,omitempty"`
	UpdatedDate     *time.Time `json:"updatedDate,omitempty"`
	Views           *int32     `json:"views,omitempty"`
}

// GalleryWidgetsListItem defines model for GalleryWidgetsListItem.
type GalleryWidgetsListItem struct {
	CreatedDate *time.Time `json:"createdDate,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`
	ImageUrl    *string    `json:"imageUrl,omitempty"`
	Likes       *int32     `json:"likes,omitempty"`
	Posts       *int32     `json:"posts,omitempty"`
	Title       *string    `json:"title,omitempty"`
	Views       *int32     `json:"views,omitempty"`
}

// GroupFunctionDTO defines model for GroupFunctionDTO.
type GroupFunctionDTO struct {
	Name   *string   `json:"name,omitempty"`
	Params *[]string `json:"params,omitempty"`
}

// GroupItemDTO defines model for GroupItemDTO.
type GroupItemDTO struct {
	Category   *string           `json:"category,omitempty"`
	Function   *GroupFunctionDTO `json:"function,omitempty"`
	GroupNames *[]string         `json:"groupNames,omitempty"`
	GroupType  *string           `json:"groupType,omitempty"`
	Label      *string           `json:"label,omitempty"`
	Name       *string           `json:"name,omitempty"`
	Tags       *[]string         `json:"tags,omitempty"`
	Type       *string           `json:"type,omitempty"`
}

// HistoryDataBean defines model for HistoryDataBean.
type HistoryDataBean struct {
	State *string `json:"state,omitempty"`
	Time  *int64  `json:"time,omitempty"`
}

// HumanLanguageInterpreterDTO defines model for HumanLanguageInterpreterDTO.
type HumanLanguageInterpreterDTO struct {
	Id      *string   `json:"id,omitempty"`
	Label   *string   `json:"label,omitempty"`
	Locales *[]string `json:"locales,omitempty"`
}

// IconSet defines model for IconSet.
type IconSet struct {
	Description *string           `json:"description,omitempty"`
	Formats     *[]IconSetFormats `json:"formats,omitempty"`
	Id          *string           `json:"id,omitempty"`
	Label       *string           `json:"label,omitempty"`
}

// IconSetFormats defines model for IconSet.Formats.
type IconSetFormats string

// ItemChannelLinkDTO defines model for ItemChannelLinkDTO.
type ItemChannelLinkDTO struct {
	ChannelUID    *string                           `json:"channelUID,omitempty"`
	Configuration *ItemChannelLinkDTO_Configuration `json:"configuration,omitempty"`
	ItemName      *string                           `json:"itemName,omitempty"`
}

// ItemChannelLinkDTO_Configuration defines model for ItemChannelLinkDTO.Configuration.
type ItemChannelLinkDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ItemHistoryDTO defines model for ItemHistoryDTO.
type ItemHistoryDTO struct {
	Data         *[]HistoryDataBean `json:"data,omitempty"`
	Datapoints   *string            `json:"datapoints,omitempty"`
	Name         *string            `json:"name,omitempty"`
	Totalrecords *string            `json:"totalrecords,omitempty"`
}

// Links defines model for Links.
type Links struct {
	Type *string `json:"type,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// MappingDTO defines model for MappingDTO.
type MappingDTO struct {
	Command *string `json:"command,omitempty"`
	Label   *string `json:"label,omitempty"`
}

// MetadataDTO defines model for MetadataDTO.
type MetadataDTO struct {
	Config *MetadataDTO_Config `json:"config,omitempty"`
	Value  *string             `json:"value,omitempty"`
}

// MetadataDTO_Config defines model for MetadataDTO.Config.
type MetadataDTO_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Module defines model for Module.
type Module struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// ModuleDTO defines model for ModuleDTO.
type ModuleDTO struct {
	Configuration *ModuleDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                  `json:"description,omitempty"`
	Id            *string                  `json:"id,omitempty"`
	Label         *string                  `json:"label,omitempty"`
	Type          *string                  `json:"type,omitempty"`
}

// ModuleDTO_Configuration defines model for ModuleDTO.Configuration.
type ModuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ModuleTypeDTO defines model for ModuleTypeDTO.
type ModuleTypeDTO struct {
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Label              *string                          `json:"label,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *ModuleTypeDTOVisibility         `json:"visibility,omitempty"`
}

// ModuleTypeDTOVisibility defines model for ModuleTypeDTO.Visibility.
type ModuleTypeDTOVisibility string

// PageDTO defines model for PageDTO.
type PageDTO struct {
	Icon    *string      `json:"icon,omitempty"`
	Id      *string      `json:"id,omitempty"`
	Leaf    *bool        `json:"leaf,omitempty"`
	Link    *string      `json:"link,omitempty"`
	Parent  *PageDTO     `json:"parent,omitempty"`
	Timeout *bool        `json:"timeout,omitempty"`
	Title   *string      `json:"title,omitempty"`
	Widgets *[]WidgetDTO `json:"widgets,omitempty"`
}

// ParameterOption defines model for ParameterOption.
type ParameterOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ParameterOptionDTO defines model for ParameterOptionDTO.
type ParameterOptionDTO struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// PersistenceItemInfo defines model for PersistenceItemInfo.
type PersistenceItemInfo struct {
	Count    *int32     `json:"count,omitempty"`
	Earliest *time.Time `json:"earliest,omitempty"`
	Latest   *time.Time `json:"latest,omitempty"`
	Name     *string    `json:"name,omitempty"`
}

// PersistenceServiceDTO defines model for PersistenceServiceDTO.
type PersistenceServiceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// ProfileTypeDTO defines model for ProfileTypeDTO.
type ProfileTypeDTO struct {
	Kind               *string   `json:"kind,omitempty"`
	Label              *string   `json:"label,omitempty"`
	SupportedItemTypes *[]string `json:"supportedItemTypes,omitempty"`
	Uid                *string   `json:"uid,omitempty"`
}

// RootBean defines model for RootBean.
type RootBean struct {
	Links             *[]Links     `json:"links,omitempty"`
	Locale            *string      `json:"locale,omitempty"`
	MeasurementSystem *string      `json:"measurementSystem,omitempty"`
	RuntimeInfo       *RuntimeInfo `json:"runtimeInfo,omitempty"`
	Version           *string      `json:"version,omitempty"`
}

// RootUIComponent defines model for RootUIComponent.
type RootUIComponent struct {
	Component *string                 `json:"component,omitempty"`
	Config    *RootUIComponent_Config `json:"config,omitempty"`
	Props     *ConfigDescriptionDTO   `json:"props,omitempty"`
	Slots     *RootUIComponent_Slots  `json:"slots,omitempty"`
	Tags      *[]string               `json:"tags,omitempty"`
	Timestamp *time.Time              `json:"timestamp,omitempty"`
	Type      *string                 `json:"type,omitempty"`
	Uid       *string                 `json:"uid,omitempty"`
}

// RootUIComponent_Config defines model for RootUIComponent.Config.
type RootUIComponent_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// RootUIComponent_Slots defines model for RootUIComponent.Slots.
type RootUIComponent_Slots struct {
	AdditionalProperties map[string][]UIComponent `json:"-"`
}

// Rule defines model for Rule.
type Rule struct {
	Actions                   *[]Action                     `json:"actions,omitempty"`
	Conditions                *[]Condition                  `json:"conditions,omitempty"`
	Configuration             *Configuration                `json:"configuration,omitempty"`
	ConfigurationDescriptions *[]ConfigDescriptionParameter `json:"configurationDescriptions,omitempty"`
	Description               *string                       `json:"description,omitempty"`
	Modules                   *[]Module                     `json:"modules,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	Tags                      *[]string                     `json:"tags,omitempty"`
	TemplateUID               *string                       `json:"templateUID,omitempty"`
	Triggers                  *[]Trigger                    `json:"triggers,omitempty"`
	Uid                       *string                       `json:"uid,omitempty"`
	Visibility                *RuleVisibility               `json:"visibility,omitempty"`
}

// RuleVisibility defines model for Rule.Visibility.
type RuleVisibility string

// RuleDTO defines model for RuleDTO.
type RuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Configuration      *RuleDTO_Configuration           `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *RuleDTOVisibility               `json:"visibility,omitempty"`
}

// RuleDTO_Configuration defines model for RuleDTO.Configuration.
type RuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// RuleDTOVisibility defines model for RuleDTO.Visibility.
type RuleDTOVisibility string

// RuleExecution defines model for RuleExecution.
type RuleExecution struct {
	Date *time.Time `json:"date,omitempty"`
	Rule *Rule      `json:"rule,omitempty"`
}

// RuleStatusInfo defines model for RuleStatusInfo.
type RuleStatusInfo struct {
	Description  *string                     `json:"description,omitempty"`
	Status       *RuleStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *RuleStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// RuleStatusInfoStatus defines model for RuleStatusInfo.Status.
type RuleStatusInfoStatus string

// RuleStatusInfoStatusDetail defines model for RuleStatusInfo.StatusDetail.
type RuleStatusInfoStatusDetail string

// RuntimeInfo defines model for RuntimeInfo.
type RuntimeInfo struct {
	BuildString *string `json:"buildString,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// SitemapDTO defines model for SitemapDTO.
type SitemapDTO struct {
	Homepage *PageDTO `json:"homepage,omitempty"`
	Icon     *string  `json:"icon,omitempty"`
	Label    *string  `json:"label,omitempty"`
	Link     *string  `json:"link,omitempty"`
	Name     *string  `json:"name,omitempty"`
}

// StateDescription defines model for StateDescription.
type StateDescription struct {
	Maximum  *float32       `json:"maximum,omitempty"`
	Minimum  *float32       `json:"minimum,omitempty"`
	Options  *[]StateOption `json:"options,omitempty"`
	Pattern  *string        `json:"pattern,omitempty"`
	ReadOnly *bool          `json:"readOnly,omitempty"`
	Step     *float32       `json:"step,omitempty"`
}

// StateOption defines model for StateOption.
type StateOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// StrippedThingTypeDTO defines model for StrippedThingTypeDTO.
type StrippedThingTypeDTO struct {
	UID                     *string   `json:"UID,omitempty"`
	Bridge                  *bool     `json:"bridge,omitempty"`
	Category                *string   `json:"category,omitempty"`
	Description             *string   `json:"description,omitempty"`
	Label                   *string   `json:"label,omitempty"`
	Listed                  *bool     `json:"listed,omitempty"`
	SupportedBridgeTypeUIDs *[]string `json:"supportedBridgeTypeUIDs,omitempty"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	AvailableProcessors *int32  `json:"availableProcessors,omitempty"`
	ConfigFolder        *string `json:"configFolder,omitempty"`
	FreeMemory          *int64  `json:"freeMemory,omitempty"`
	JavaVendor          *string `json:"javaVendor,omitempty"`
	JavaVendorVersion   *string `json:"javaVendorVersion,omitempty"`
	JavaVersion         *string `json:"javaVersion,omitempty"`
	LogFolder           *string `json:"logFolder,omitempty"`
	OsArchitecture      *string `json:"osArchitecture,omitempty"`
	OsName              *string `json:"osName,omitempty"`
	OsVersion           *string `json:"osVersion,omitempty"`
	TotalMemory         *int64  `json:"totalMemory,omitempty"`
	UserdataFolder      *string `json:"userdataFolder,omitempty"`
}

// SystemInfoBean defines model for SystemInfoBean.
type SystemInfoBean struct {
	SystemInfo *SystemInfo `json:"systemInfo,omitempty"`
}

// Template defines model for Template.
type Template struct {
	Description *string             `json:"description,omitempty"`
	Label       *string             `json:"label,omitempty"`
	Tags        *[]string           `json:"tags,omitempty"`
	Uid         *string             `json:"uid,omitempty"`
	Visibility  *TemplateVisibility `json:"visibility,omitempty"`
}

// TemplateVisibility defines model for Template.Visibility.
type TemplateVisibility string

// ThingDTO defines model for ThingDTO.
type ThingDTO struct {
	UID           *string                 `json:"UID,omitempty"`
	BridgeUID     *string                 `json:"bridgeUID,omitempty"`
	Channels      *[]ChannelDTO           `json:"channels,omitempty"`
	Configuration *ThingDTO_Configuration `json:"configuration,omitempty"`
	Label         *string                 `json:"label,omitempty"`
	Location      *string                 `json:"location,omitempty"`
	Properties    *ThingDTO_Properties    `json:"properties,omitempty"`
	ThingTypeUID  *string                 `json:"thingTypeUID,omitempty"`
}

// ThingDTO_Configuration defines model for ThingDTO.Configuration.
type ThingDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ThingDTO_Properties defines model for ThingDTO.Properties.
type ThingDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ThingStatusInfo defines model for ThingStatusInfo.
type ThingStatusInfo struct {
	Description  *string                      `json:"description,omitempty"`
	Status       *ThingStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *ThingStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// ThingStatusInfoStatus defines model for ThingStatusInfo.Status.
type ThingStatusInfoStatus string

// ThingStatusInfoStatusDetail defines model for ThingStatusInfo.StatusDetail.
type ThingStatusInfoStatusDetail string

// ThingTypeDTO defines model for ThingTypeDTO.
type ThingTypeDTO struct {
	UID                      *string                               `json:"UID,omitempty"`
	Bridge                   *bool                                 `json:"bridge,omitempty"`
	Category                 *string                               `json:"category,omitempty"`
	ChannelGroups            *[]ChannelGroupDefinitionDTO          `json:"channelGroups,omitempty"`
	Channels                 *[]ChannelDefinitionDTO               `json:"channels,omitempty"`
	ConfigParameters         *[]ConfigDescriptionParameterDTO      `json:"configParameters,omitempty"`
	Description              *string                               `json:"description,omitempty"`
	ExtensibleChannelTypeIds *[]string                             `json:"extensibleChannelTypeIds,omitempty"`
	Label                    *string                               `json:"label,omitempty"`
	Listed                   *bool                                 `json:"listed,omitempty"`
	ParameterGroups          *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Properties               *ThingTypeDTO_Properties              `json:"properties,omitempty"`
	SupportedBridgeTypeUIDs  *[]string                             `json:"supportedBridgeTypeUIDs,omitempty"`
}

// ThingTypeDTO_Properties defines model for ThingTypeDTO.Properties.
type ThingTypeDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// TileDTO defines model for TileDTO.
type TileDTO struct {
	ImageUrl *string `json:"imageUrl,omitempty"`
	Name     *string `json:"name,omitempty"`
	Overlay  *string `json:"overlay,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// TokenResponseDTO defines model for TokenResponseDTO.
type TokenResponseDTO struct {
	AccessToken  *string  `json:"access_token,omitempty"`
	ExpiresIn    *int32   `json:"expires_in,omitempty"`
	RefreshToken *string  `json:"refresh_token,omitempty"`
	Scope        *string  `json:"scope,omitempty"`
	TokenType    *string  `json:"token_type,omitempty"`
	User         *UserDTO `json:"user,omitempty"`
}

// Trigger defines model for Trigger.
type Trigger struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// TriggerDTO defines model for TriggerDTO.
type TriggerDTO struct {
	Configuration *TriggerDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                   `json:"description,omitempty"`
	Id            *string                   `json:"id,omitempty"`
	Label         *string                   `json:"label,omitempty"`
	Type          *string                   `json:"type,omitempty"`
}

// TriggerDTO_Configuration defines model for TriggerDTO.Configuration.
type TriggerDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UIComponent defines model for UIComponent.
type UIComponent struct {
	Component *string             `json:"component,omitempty"`
	Config    *UIComponent_Config `json:"config,omitempty"`
	Type      *string             `json:"type,omitempty"`
}

// UIComponent_Config defines model for UIComponent.Config.
type UIComponent_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UserApiTokenDTO defines model for UserApiTokenDTO.
type UserApiTokenDTO struct {
	CreatedTime *time.Time `json:"createdTime,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Scope       *string    `json:"scope,omitempty"`
}

// UserDTO defines model for UserDTO.
type UserDTO struct {
	Name  *string   `json:"name,omitempty"`
	Roles *[]string `json:"roles,omitempty"`
}

// UserSessionDTO defines model for UserSessionDTO.
type UserSessionDTO struct {
	ClientId        *string    `json:"clientId,omitempty"`
	CreatedTime     *time.Time `json:"createdTime,omitempty"`
	LastRefreshTime *time.Time `json:"lastRefreshTime,omitempty"`
	Scope           *string    `json:"scope,omitempty"`
	SessionId       *string    `json:"sessionId,omitempty"`
}

// VoiceDTO defines model for VoiceDTO.
type VoiceDTO struct {
	Id     *string `json:"id,omitempty"`
	Label  *string `json:"label,omitempty"`
	Locale *string `json:"locale,omitempty"`
}

// WidgetDTO defines model for WidgetDTO.
type WidgetDTO struct {
	Encoding      *string          `json:"encoding,omitempty"`
	Height        *int32           `json:"height,omitempty"`
	Icon          *string          `json:"icon,omitempty"`
	Item          *EnrichedItemDTO `json:"item,omitempty"`
	Label         *string          `json:"label,omitempty"`
	Labelcolor    *string          `json:"labelcolor,omitempty"`
	Legend        *bool            `json:"legend,omitempty"`
	LinkedPage    *PageDTO         `json:"linkedPage,omitempty"`
	Mappings      *[]MappingDTO    `json:"mappings,omitempty"`
	MaxValue      *float32         `json:"maxValue,omitempty"`
	MinValue      *float32         `json:"minValue,omitempty"`
	Name          *string          `json:"name,omitempty"`
	Period        *string          `json:"period,omitempty"`
	Refresh       *int32           `json:"refresh,omitempty"`
	SendFrequency *int32           `json:"sendFrequency,omitempty"`
	Separator     *string          `json:"separator,omitempty"`
	Service       *string          `json:"service,omitempty"`
	State         *string          `json:"state,omitempty"`
	Step          *float32         `json:"step,omitempty"`
	SwitchSupport *bool            `json:"switchSupport,omitempty"`
	Type          *string          `json:"type,omitempty"`
	Url           *string          `json:"url,omitempty"`
	Valuecolor    *string          `json:"valuecolor,omitempty"`
	Visibility    *bool            `json:"visibility,omitempty"`
	WidgetId      *string          `json:"widgetId,omitempty"`
}

// GetAddonsParams defines parameters for GetAddons.
type GetAddonsParams struct {
	// service ID
	ServiceId *string `json:"serviceId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonTypesParams defines parameters for GetAddonTypes.
type GetAddonTypesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonServicesParams defines parameters for GetAddonServices.
type GetAddonServicesParams struct {
	// service ID
	ServiceId *string `json:"serviceId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonByIdParams defines parameters for GetAddonById.
type GetAddonByIdParams struct {
	// service ID
	ServiceId *string `json:"serviceId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InstallAddonByIdParams defines parameters for InstallAddonById.
type InstallAddonByIdParams struct {
	// service ID
	ServiceId *string `json:"serviceId,omitempty"`
}

// UninstallAddonParams defines parameters for UninstallAddon.
type UninstallAddonParams struct {
	// service ID
	ServiceId *string `json:"serviceId,omitempty"`
}

// GetAudioDefaultSinkParams defines parameters for GetAudioDefaultSink.
type GetAudioDefaultSinkParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioDefaultSourceParams defines parameters for GetAudioDefaultSource.
type GetAudioDefaultSourceParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSinksParams defines parameters for GetAudioSinks.
type GetAudioSinksParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSourcesParams defines parameters for GetAudioSources.
type GetAudioSourcesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetOAuthTokenParams defines parameters for GetOAuthToken.
type GetOAuthTokenParams struct {
	UseCookie *bool `json:"useCookie,omitempty"`
}

// GetBindingsParams defines parameters for GetBindings.
type GetBindingsParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateBindingConfigurationJSONBody defines parameters for UpdateBindingConfiguration.
type UpdateBindingConfigurationJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// GetChannelTypesParams defines parameters for GetChannelTypes.
type GetChannelTypesParams struct {
	// filter UIDs by prefix (multiple comma-separated prefixes allowed, for example: 'system,mqtt')
	Prefixes *string `json:"prefixes,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetChannelTypeByUIDParams defines parameters for GetChannelTypeByUID.
type GetChannelTypeByUIDParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionsParams defines parameters for GetConfigDescriptions.
type GetConfigDescriptionsParams struct {
	// scheme filter
	Scheme *string `json:"scheme,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionByURIParams defines parameters for GetConfigDescriptionByURI.
type GetConfigDescriptionByURIParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// topics
	Topics *string `json:"topics,omitempty"`
}

// GetIconSetsParams defines parameters for GetIconSets.
type GetIconSetsParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// ApproveInboxItemByIdParams defines parameters for ApproveInboxItemById.
type ApproveInboxItemByIdParams struct {
	// new thing ID
	NewThingId *string `json:"newThingId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsParams defines parameters for GetItems.
type GetItemsParams struct {
	// item type filter
	Type *string `json:"type,omitempty"`

	// item tag filter
	Tags *string `json:"tags,omitempty"`

	// metadata selector
	Metadata *string `json:"metadata,omitempty"`

	// get member items recursively
	Recursive *bool `json:"recursive,omitempty"`

	// limit output to the given fields (comma separated)
	Fields *string `json:"fields,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddOrUpdateItemsInRegistryJSONBody defines parameters for AddOrUpdateItemsInRegistry.
type AddOrUpdateItemsInRegistryJSONBody []GroupItemDTO

// GetItemByNameParams defines parameters for GetItemByName.
type GetItemByNameParams struct {
	// metadata selector
	Metadata *string `json:"metadata,omitempty"`

	// get member items if the item is a group item
	Recursive *bool `json:"recursive,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddOrUpdateItemInRegistryJSONBody defines parameters for AddOrUpdateItemInRegistry.
type AddOrUpdateItemInRegistryJSONBody GroupItemDTO

// AddOrUpdateItemInRegistryParams defines parameters for AddOrUpdateItemInRegistry.
type AddOrUpdateItemInRegistryParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddMetadataToItemJSONBody defines parameters for AddMetadataToItem.
type AddMetadataToItemJSONBody MetadataDTO

// UpdateItemStateParams defines parameters for UpdateItemState.
type UpdateItemStateParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemLinksParams defines parameters for GetItemLinks.
type GetItemLinksParams struct {
	// filter by channel UID
	ChannelUID *string `json:"channelUID,omitempty"`

	// filter by item name
	ItemName *string `json:"itemName,omitempty"`
}

// LinkItemToChannelJSONBody defines parameters for LinkItemToChannel.
type LinkItemToChannelJSONBody ItemChannelLinkDTO

// GetModuleTypesParams defines parameters for GetModuleTypes.
type GetModuleTypesParams struct {
	// tags for filtering
	Tags *string `json:"tags,omitempty"`

	// filtering by action, condition or trigger
	Type *string `json:"type,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetModuleTypeByIdParams defines parameters for GetModuleTypeById.
type GetModuleTypeByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetPersistenceServicesParams defines parameters for GetPersistenceServices.
type GetPersistenceServicesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsForPersistenceServiceParams defines parameters for GetItemsForPersistenceService.
type GetItemsForPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`
}

// DeleteItemFromPersistenceServiceParams defines parameters for DeleteItemFromPersistenceService.
type DeleteItemFromPersistenceServiceParams struct {
	// Id of the persistence service.
	ServiceId string `json:"serviceId"`

	// Start time of the data to return. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime string `json:"starttime"`

	// End time of the data to return. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime string `json:"endtime"`
}

// GetItemDataFromPersistenceServiceParams defines parameters for GetItemDataFromPersistenceService.
type GetItemDataFromPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`

	// Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime *string `json:"starttime,omitempty"`

	// End time of the data to return. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime *string `json:"endtime,omitempty"`

	// Page number of data to return. This parameter will enable paging.
	Page *int32 `json:"page,omitempty"`

	// The length of each page.
	Pagelength *int32 `json:"pagelength,omitempty"`

	// Gets one value before and after the requested period.
	Boundary *bool `json:"boundary,omitempty"`
}

// StoreItemDataInPersistenceServiceParams defines parameters for StoreItemDataInPersistenceService.
type StoreItemDataInPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`

	// Time of the data to be stored. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Time string `json:"time"`

	// The state to store.
	State string `json:"state"`
}

// GetProfileTypesParams defines parameters for GetProfileTypes.
type GetProfileTypesParams struct {
	// channel type filter
	ChannelTypeUID *string `json:"channelTypeUID,omitempty"`

	// item type filter
	ItemType *string `json:"itemType,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	Prefix *string   `json:"prefix,omitempty"`
	Tags   *[]string `json:"tags,omitempty"`

	// summary fields only
	Summary *bool `json:"summary,omitempty"`
}

// CreateRuleJSONBody defines parameters for CreateRule.
type CreateRuleJSONBody RuleDTO

// GetScheduleRuleSimulationsParams defines parameters for GetScheduleRuleSimulations.
type GetScheduleRuleSimulationsParams struct {
	// Start time of the simulated rule executions. Will default to the current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	From *string `json:"from,omitempty"`

	// End time of the simulated rule executions. Will default to 30 days after the start time. Must be less than 180 days after the given start time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Until *string `json:"until,omitempty"`
}

// UpdateRuleJSONBody defines parameters for UpdateRule.
type UpdateRuleJSONBody RuleDTO

// UpdateRuleConfigurationJSONBody defines parameters for UpdateRuleConfiguration.
type UpdateRuleConfigurationJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetServicesByIdParams defines parameters for GetServicesById.
type GetServicesByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateServiceConfigJSONBody defines parameters for UpdateServiceConfig.
type UpdateServiceConfigJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UpdateServiceConfigParams defines parameters for UpdateServiceConfig.
type UpdateServiceConfigParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetServiceContextParams defines parameters for GetServiceContext.
type GetServiceContextParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetSitemapEventsParams defines parameters for GetSitemapEvents.
type GetSitemapEventsParams struct {
	// sitemap name
	Sitemap *string `json:"sitemap,omitempty"`

	// page id
	Pageid *string `json:"pageid,omitempty"`
}

// GetSitemapByNameParams defines parameters for GetSitemapByName.
type GetSitemapByNameParams struct {
	Type         *string `json:"type,omitempty"`
	Jsoncallback *string `json:"jsoncallback,omitempty"`

	// include hidden widgets
	IncludeHidden *bool `json:"includeHidden,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// PollDataForSitemapParams defines parameters for PollDataForSitemap.
type PollDataForSitemapParams struct {
	// subscriptionid
	Subscriptionid *string `json:"subscriptionid,omitempty"`

	// include hidden widgets
	IncludeHidden *bool `json:"includeHidden,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplatesParams defines parameters for GetTemplates.
type GetTemplatesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplateByIdParams defines parameters for GetTemplateById.
type GetTemplateByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypesParams defines parameters for GetThingTypes.
type GetThingTypesParams struct {
	// filter by binding Id
	BindingId *string `json:"bindingId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypeByIdParams defines parameters for GetThingTypeById.
type GetThingTypeByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingsParams defines parameters for GetThings.
type GetThingsParams struct {
	// summary fields only
	Summary *bool `json:"summary,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CreateThingInRegistryJSONBody defines parameters for CreateThingInRegistry.
type CreateThingInRegistryJSONBody ThingDTO

// CreateThingInRegistryParams defines parameters for CreateThingInRegistry.
type CreateThingInRegistryParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// RemoveThingByIdParams defines parameters for RemoveThingById.
type RemoveThingByIdParams struct {
	// force
	Force *bool `json:"force,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingByIdParams defines parameters for GetThingById.
type GetThingByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingJSONBody defines parameters for UpdateThing.
type UpdateThingJSONBody ThingDTO

// UpdateThingParams defines parameters for UpdateThing.
type UpdateThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingConfigJSONBody defines parameters for UpdateThingConfig.
type UpdateThingConfigJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UpdateThingConfigParams defines parameters for UpdateThingConfig.
type UpdateThingConfigParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingConfigStatusParams defines parameters for GetThingConfigStatus.
type GetThingConfigStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// EnableThingParams defines parameters for EnableThing.
type EnableThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingFirmwareStatusParams defines parameters for GetThingFirmwareStatus.
type GetThingFirmwareStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingFirmwareParams defines parameters for UpdateThingFirmware.
type UpdateThingFirmwareParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAvailableFirmwaresForThingParams defines parameters for GetAvailableFirmwaresForThing.
type GetAvailableFirmwaresForThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingStatusParams defines parameters for GetThingStatus.
type GetThingStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRegisteredUIComponentsInNamespaceParams defines parameters for GetRegisteredUIComponentsInNamespace.
type GetRegisteredUIComponentsInNamespaceParams struct {
	// summary fields only
	Summary *bool `json:"summary,omitempty"`
}

// AddUIComponentToNamespaceJSONBody defines parameters for AddUIComponentToNamespace.
type AddUIComponentToNamespaceJSONBody RootUIComponent

// UpdateUIComponentInNamespaceJSONBody defines parameters for UpdateUIComponentInNamespace.
type UpdateUIComponentInNamespaceJSONBody RootUIComponent

// GetVoiceInterpretersParams defines parameters for GetVoiceInterpreters.
type GetVoiceInterpretersParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextByDefaultInterpreterParams defines parameters for InterpretTextByDefaultInterpreter.
type InterpretTextByDefaultInterpreterParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetVoiceInterpreterByUIDParams defines parameters for GetVoiceInterpreterByUID.
type GetVoiceInterpreterByUIDParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextParams defines parameters for InterpretText.
type InterpretTextParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// TextToSpeechParams defines parameters for TextToSpeech.
type TextToSpeechParams struct {
	// voice id
	Voiceid *string `json:"voiceid,omitempty"`

	// audio sink id
	Sinkid *string `json:"sinkid,omitempty"`
}

// UpdateBindingConfigurationJSONRequestBody defines body for UpdateBindingConfiguration for application/json ContentType.
type UpdateBindingConfigurationJSONRequestBody UpdateBindingConfigurationJSONBody

// AddOrUpdateItemsInRegistryJSONRequestBody defines body for AddOrUpdateItemsInRegistry for application/json ContentType.
type AddOrUpdateItemsInRegistryJSONRequestBody AddOrUpdateItemsInRegistryJSONBody

// AddOrUpdateItemInRegistryJSONRequestBody defines body for AddOrUpdateItemInRegistry for application/json ContentType.
type AddOrUpdateItemInRegistryJSONRequestBody AddOrUpdateItemInRegistryJSONBody

// AddMetadataToItemJSONRequestBody defines body for AddMetadataToItem for application/json ContentType.
type AddMetadataToItemJSONRequestBody AddMetadataToItemJSONBody

// LinkItemToChannelJSONRequestBody defines body for LinkItemToChannel for application/json ContentType.
type LinkItemToChannelJSONRequestBody LinkItemToChannelJSONBody

// CreateRuleJSONRequestBody defines body for CreateRule for application/json ContentType.
type CreateRuleJSONRequestBody CreateRuleJSONBody

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody UpdateRuleJSONBody

// UpdateRuleConfigurationJSONRequestBody defines body for UpdateRuleConfiguration for application/json ContentType.
type UpdateRuleConfigurationJSONRequestBody UpdateRuleConfigurationJSONBody

// UpdateServiceConfigJSONRequestBody defines body for UpdateServiceConfig for application/json ContentType.
type UpdateServiceConfigJSONRequestBody UpdateServiceConfigJSONBody

// CreateThingInRegistryJSONRequestBody defines body for CreateThingInRegistry for application/json ContentType.
type CreateThingInRegistryJSONRequestBody CreateThingInRegistryJSONBody

// UpdateThingJSONRequestBody defines body for UpdateThing for application/json ContentType.
type UpdateThingJSONRequestBody UpdateThingJSONBody

// UpdateThingConfigJSONRequestBody defines body for UpdateThingConfig for application/json ContentType.
type UpdateThingConfigJSONRequestBody UpdateThingConfigJSONBody

// AddUIComponentToNamespaceJSONRequestBody defines body for AddUIComponentToNamespace for application/json ContentType.
type AddUIComponentToNamespaceJSONRequestBody AddUIComponentToNamespaceJSONBody

// UpdateUIComponentInNamespaceJSONRequestBody defines body for UpdateUIComponentInNamespace for application/json ContentType.
type UpdateUIComponentInNamespaceJSONRequestBody UpdateUIComponentInNamespaceJSONBody

// Getter for additional properties for UpdateBindingConfigurationJSONBody. Returns the specified
// element and whether it was found
func (a UpdateBindingConfigurationJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateBindingConfigurationJSONBody
func (a *UpdateBindingConfigurationJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateBindingConfigurationJSONBody to handle AdditionalProperties
func (a *UpdateBindingConfigurationJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateBindingConfigurationJSONBody to handle AdditionalProperties
func (a UpdateBindingConfigurationJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateRuleConfigurationJSONBody. Returns the specified
// element and whether it was found
func (a UpdateRuleConfigurationJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateRuleConfigurationJSONBody
func (a *UpdateRuleConfigurationJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateRuleConfigurationJSONBody to handle AdditionalProperties
func (a *UpdateRuleConfigurationJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateRuleConfigurationJSONBody to handle AdditionalProperties
func (a UpdateRuleConfigurationJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateServiceConfigJSONBody. Returns the specified
// element and whether it was found
func (a UpdateServiceConfigJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateServiceConfigJSONBody
func (a *UpdateServiceConfigJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateServiceConfigJSONBody to handle AdditionalProperties
func (a *UpdateServiceConfigJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateServiceConfigJSONBody to handle AdditionalProperties
func (a UpdateServiceConfigJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateThingConfigJSONBody. Returns the specified
// element and whether it was found
func (a UpdateThingConfigJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateThingConfigJSONBody
func (a *UpdateThingConfigJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateThingConfigJSONBody to handle AdditionalProperties
func (a *UpdateThingConfigJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateThingConfigJSONBody to handle AdditionalProperties
func (a UpdateThingConfigJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Action_Inputs. Returns the specified
// element and whether it was found
func (a Action_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Action_Inputs
func (a *Action_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Action_Inputs to handle AdditionalProperties
func (a *Action_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Action_Inputs to handle AdditionalProperties
func (a Action_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActionDTO_Configuration. Returns the specified
// element and whether it was found
func (a ActionDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActionDTO_Configuration
func (a *ActionDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActionDTO_Configuration to handle AdditionalProperties
func (a *ActionDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActionDTO_Configuration to handle AdditionalProperties
func (a ActionDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActionDTO_Inputs. Returns the specified
// element and whether it was found
func (a ActionDTO_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActionDTO_Inputs
func (a *ActionDTO_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActionDTO_Inputs to handle AdditionalProperties
func (a *ActionDTO_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActionDTO_Inputs to handle AdditionalProperties
func (a ActionDTO_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Addon_Properties. Returns the specified
// element and whether it was found
func (a Addon_Properties) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Addon_Properties
func (a *Addon_Properties) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Addon_Properties to handle AdditionalProperties
func (a *Addon_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Addon_Properties to handle AdditionalProperties
func (a Addon_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDTO_Configuration. Returns the specified
// element and whether it was found
func (a ChannelDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDTO_Configuration
func (a *ChannelDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDTO_Configuration to handle AdditionalProperties
func (a *ChannelDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDTO_Configuration to handle AdditionalProperties
func (a ChannelDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDTO_Properties. Returns the specified
// element and whether it was found
func (a ChannelDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDTO_Properties
func (a *ChannelDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDTO_Properties to handle AdditionalProperties
func (a *ChannelDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDTO_Properties to handle AdditionalProperties
func (a ChannelDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDefinitionDTO_Properties. Returns the specified
// element and whether it was found
func (a ChannelDefinitionDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDefinitionDTO_Properties
func (a *ChannelDefinitionDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDefinitionDTO_Properties to handle AdditionalProperties
func (a *ChannelDefinitionDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDefinitionDTO_Properties to handle AdditionalProperties
func (a ChannelDefinitionDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Condition_Inputs. Returns the specified
// element and whether it was found
func (a Condition_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Condition_Inputs
func (a *Condition_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Condition_Inputs to handle AdditionalProperties
func (a *Condition_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Condition_Inputs to handle AdditionalProperties
func (a Condition_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConditionDTO_Configuration. Returns the specified
// element and whether it was found
func (a ConditionDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConditionDTO_Configuration
func (a *ConditionDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConditionDTO_Configuration to handle AdditionalProperties
func (a *ConditionDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConditionDTO_Configuration to handle AdditionalProperties
func (a ConditionDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConditionDTO_Inputs. Returns the specified
// element and whether it was found
func (a ConditionDTO_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConditionDTO_Inputs
func (a *ConditionDTO_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConditionDTO_Inputs to handle AdditionalProperties
func (a *ConditionDTO_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConditionDTO_Inputs to handle AdditionalProperties
func (a ConditionDTO_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Configuration_Properties. Returns the specified
// element and whether it was found
func (a Configuration_Properties) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Configuration_Properties
func (a *Configuration_Properties) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Configuration_Properties to handle AdditionalProperties
func (a *Configuration_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Configuration_Properties to handle AdditionalProperties
func (a Configuration_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DiscoveryResultDTO_Properties. Returns the specified
// element and whether it was found
func (a DiscoveryResultDTO_Properties) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DiscoveryResultDTO_Properties
func (a *DiscoveryResultDTO_Properties) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DiscoveryResultDTO_Properties to handle AdditionalProperties
func (a *DiscoveryResultDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DiscoveryResultDTO_Properties to handle AdditionalProperties
func (a DiscoveryResultDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedChannelDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedChannelDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedChannelDTO_Configuration
func (a *EnrichedChannelDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedChannelDTO_Configuration to handle AdditionalProperties
func (a *EnrichedChannelDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedChannelDTO_Configuration to handle AdditionalProperties
func (a EnrichedChannelDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedChannelDTO_Properties. Returns the specified
// element and whether it was found
func (a EnrichedChannelDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedChannelDTO_Properties
func (a *EnrichedChannelDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedChannelDTO_Properties to handle AdditionalProperties
func (a *EnrichedChannelDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedChannelDTO_Properties to handle AdditionalProperties
func (a EnrichedChannelDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedItemChannelLinkDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedItemChannelLinkDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedItemChannelLinkDTO_Configuration
func (a *EnrichedItemChannelLinkDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a *EnrichedItemChannelLinkDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a EnrichedItemChannelLinkDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedItemDTO_Metadata. Returns the specified
// element and whether it was found
func (a EnrichedItemDTO_Metadata) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedItemDTO_Metadata
func (a *EnrichedItemDTO_Metadata) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedItemDTO_Metadata to handle AdditionalProperties
func (a *EnrichedItemDTO_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedItemDTO_Metadata to handle AdditionalProperties
func (a EnrichedItemDTO_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedRuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedRuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedRuleDTO_Configuration
func (a *EnrichedRuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedRuleDTO_Configuration to handle AdditionalProperties
func (a *EnrichedRuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedRuleDTO_Configuration to handle AdditionalProperties
func (a EnrichedRuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedThingDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedThingDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedThingDTO_Configuration
func (a *EnrichedThingDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedThingDTO_Configuration to handle AdditionalProperties
func (a *EnrichedThingDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedThingDTO_Configuration to handle AdditionalProperties
func (a EnrichedThingDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedThingDTO_Properties. Returns the specified
// element and whether it was found
func (a EnrichedThingDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedThingDTO_Properties
func (a *EnrichedThingDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedThingDTO_Properties to handle AdditionalProperties
func (a *EnrichedThingDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedThingDTO_Properties to handle AdditionalProperties
func (a EnrichedThingDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ItemChannelLinkDTO_Configuration. Returns the specified
// element and whether it was found
func (a ItemChannelLinkDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ItemChannelLinkDTO_Configuration
func (a *ItemChannelLinkDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a *ItemChannelLinkDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a ItemChannelLinkDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MetadataDTO_Config. Returns the specified
// element and whether it was found
func (a MetadataDTO_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MetadataDTO_Config
func (a *MetadataDTO_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MetadataDTO_Config to handle AdditionalProperties
func (a *MetadataDTO_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MetadataDTO_Config to handle AdditionalProperties
func (a MetadataDTO_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ModuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a ModuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModuleDTO_Configuration
func (a *ModuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModuleDTO_Configuration to handle AdditionalProperties
func (a *ModuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModuleDTO_Configuration to handle AdditionalProperties
func (a ModuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RootUIComponent_Config. Returns the specified
// element and whether it was found
func (a RootUIComponent_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RootUIComponent_Config
func (a *RootUIComponent_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RootUIComponent_Config to handle AdditionalProperties
func (a *RootUIComponent_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RootUIComponent_Config to handle AdditionalProperties
func (a RootUIComponent_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RootUIComponent_Slots. Returns the specified
// element and whether it was found
func (a RootUIComponent_Slots) Get(fieldName string) (value []UIComponent, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RootUIComponent_Slots
func (a *RootUIComponent_Slots) Set(fieldName string, value []UIComponent) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]UIComponent)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RootUIComponent_Slots to handle AdditionalProperties
func (a *RootUIComponent_Slots) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]UIComponent)
		for fieldName, fieldBuf := range object {
			var fieldVal []UIComponent
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RootUIComponent_Slots to handle AdditionalProperties
func (a RootUIComponent_Slots) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a RuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RuleDTO_Configuration
func (a *RuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RuleDTO_Configuration to handle AdditionalProperties
func (a *RuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RuleDTO_Configuration to handle AdditionalProperties
func (a RuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingDTO_Configuration. Returns the specified
// element and whether it was found
func (a ThingDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingDTO_Configuration
func (a *ThingDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingDTO_Configuration to handle AdditionalProperties
func (a *ThingDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingDTO_Configuration to handle AdditionalProperties
func (a ThingDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingDTO_Properties. Returns the specified
// element and whether it was found
func (a ThingDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingDTO_Properties
func (a *ThingDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingDTO_Properties to handle AdditionalProperties
func (a *ThingDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingDTO_Properties to handle AdditionalProperties
func (a ThingDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingTypeDTO_Properties. Returns the specified
// element and whether it was found
func (a ThingTypeDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingTypeDTO_Properties
func (a *ThingTypeDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingTypeDTO_Properties to handle AdditionalProperties
func (a *ThingTypeDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingTypeDTO_Properties to handle AdditionalProperties
func (a ThingTypeDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TriggerDTO_Configuration. Returns the specified
// element and whether it was found
func (a TriggerDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TriggerDTO_Configuration
func (a *TriggerDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TriggerDTO_Configuration to handle AdditionalProperties
func (a *TriggerDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TriggerDTO_Configuration to handle AdditionalProperties
func (a TriggerDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UIComponent_Config. Returns the specified
// element and whether it was found
func (a UIComponent_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UIComponent_Config
func (a *UIComponent_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UIComponent_Config to handle AdditionalProperties
func (a *UIComponent_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UIComponent_Config to handle AdditionalProperties
func (a UIComponent_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetRoot request
	GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddons request
	GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonTypes request
	GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonServices request
	GetAddonServices(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAddonFromURL request
	InstallAddonFromURL(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonById request
	GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAddonById request
	InstallAddonById(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallAddon request
	UninstallAddon(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSink request
	GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSource request
	GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSinks request
	GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSources request
	GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiTokens request
	GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveApiToken request
	RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSession request with any body
	DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionsForCurrentUser request
	GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindings request
	GetBindings(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindingConfiguration request
	GetBindingConfiguration(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBindingConfiguration request with any body
	UpdateBindingConfigurationWithBody(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBindingConfiguration(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypes request
	GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypeByUID request
	GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkableItemTypesByChannelTypeUID request
	GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptions request
	GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptionByURI request
	GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindingsWithDiscoverySupport request
	GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Scan request
	Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitNewStateTacker request
	InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemListForStateUpdates request with any body
	UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGalleryWidgetList request
	GetGalleryWidgetList(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGalleryWidgetsItem request
	GetGalleryWidgetsItem(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIconSets request
	GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscoveredInboxItems request
	GetDiscoveredInboxItems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromInbox request
	RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveInboxItemById request with any body
	ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FlagInboxItemAsIgnored request
	FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveIgnoreFlagOnInboxItem request
	RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItems request
	GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemsInRegistry request with any body
	AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMemberFromGroupItem request
	RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMemberToGroupItem request
	AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromRegistry request
	RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemByName request
	GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendItemCommand request with any body
	SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemInRegistry request with any body
	AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMetadataFromItem request
	RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMetadataToItem request with any body
	AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemState request
	GetItemState(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemState request with any body
	UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagFromItem request
	RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTagToItem request
	AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLinks request
	GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkItemFromChannel request
	UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLink request
	GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkItemToChannel request with any body
	LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkItemToChannel(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypes request
	GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypeById request
	GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistenceServices request
	GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemsForPersistenceService request
	GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItemFromPersistenceService request
	DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemDataFromPersistenceService request
	GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreItemDataInPersistenceService request
	StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfileTypes request
	GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRule request with any body
	CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduleRuleSimulations request
	GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleById request
	GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRule request with any body
	UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleActions request
	GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConditions request
	GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConfiguration request
	GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleConfiguration request with any body
	UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableRule request with any body
	EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunRuleNow request
	RunRuleNow(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleTriggers request
	GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleById request
	GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfig request
	GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfigParameter request
	GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRuleModuleConfigParameter request with any body
	SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesById request
	GetServicesById(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceConfig request
	DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceConfig request
	GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceConfig request with any body
	UpdateServiceConfigWithBody(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceConfig(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceContext request
	GetServiceContext(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemaps request
	GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSitemapEventSubscription request
	CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapEvents request
	GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapByName request
	GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollDataForSitemap request
	PollDataForSitemap(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInformation request
	GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateById request
	GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypes request
	GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypeById request
	GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThings request
	GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateThingInRegistry request with any body
	CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveThingById request
	RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingById request
	GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThing request with any body
	UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingConfig request with any body
	UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingConfigStatus request
	GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableThing request with any body
	EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingFirmwareStatus request
	GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingFirmware request
	UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableFirmwaresForThing request
	GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingStatus request
	GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegisteredUIComponentsInNamespace request
	GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUIComponentToNamespace request with any body
	AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUIComponentToNamespace(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUIComponentFromNamespace request
	RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUIComponentInNamespace request
	GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUIComponentInNamespace request with any body
	UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUITiles request
	GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUUID request
	GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultVoice request
	GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreters request
	GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretTextByDefaultInterpreter request with any body
	InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreterByUID request
	GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretText request with any body
	InterpretTextWithBody(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TextToSpeech request with any body
	TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoices request
	GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonServices(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAddonFromURL(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAddonFromURLRequest(c.Server, url)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonByIdRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAddonById(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAddonByIdRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallAddon(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAddonRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSourceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveApiTokenRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionsForCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindings(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindingConfiguration(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingConfigurationRequest(c.Server, bindingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBindingConfigurationWithBody(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBindingConfigurationRequestWithBody(c.Server, bindingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBindingConfiguration(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBindingConfigurationRequest(c.Server, bindingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypeByUIDRequest(c.Server, channelTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkableItemTypesByChannelTypeUIDRequest(c.Server, channelTypeUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionByURIRequest(c.Server, uri, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingsWithDiscoverySupportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanRequest(c.Server, bindingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitNewStateTackerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemListForStateUpdatesRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGalleryWidgetList(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGalleryWidgetListRequest(c.Server, galleryName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGalleryWidgetsItem(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGalleryWidgetsItemRequest(c.Server, galleryName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIconSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscoveredInboxItems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscoveredInboxItemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromInboxRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveInboxItemByIdRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFlagInboxItemAsIgnoredRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveIgnoreFlagOnInboxItemRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMemberFromGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMemberToGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromRegistryRequest(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemByNameRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendItemCommandRequestWithBody(c.Server, itemname, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequest(c.Server, itemname, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMetadataFromItemRequest(c.Server, itemname, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequestWithBody(c.Server, itemname, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequest(c.Server, itemname, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemState(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemStateRequest(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemStateRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagFromItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTagToItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkItemFromChannelRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinkRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkItemToChannelRequestWithBody(c.Server, itemName, channelUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkItemToChannel(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkItemToChannelRequest(c.Server, itemName, channelUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypeByIdRequest(c.Server, moduleTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsForPersistenceServiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemDataFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreItemDataInPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRuleSimulationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleByIdRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleActionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConditionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConfigurationRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRuleNow(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRuleNowRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleTriggersRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleByIdRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigParameterRequest(c.Server, ruleUID, moduleCategory, id, param)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRuleModuleConfigParameterRequestWithBody(c.Server, ruleUID, moduleCategory, id, param, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesById(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesByIdRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfigWithBody(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequestWithBody(c.Server, serviceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfig(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequest(c.Server, serviceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceContext(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceContextRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSitemapEventSubscriptionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapEventsRequest(c.Server, subscriptionid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapByNameRequest(c.Server, sitemapname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollDataForSitemap(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollDataForSitemapRequest(c.Server, sitemapname, pageid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateByIdRequest(c.Server, templateUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypeByIdRequest(c.Server, thingTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingConfigStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingFirmwareStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingFirmwareRequest(c.Server, thingUID, firmwareVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableFirmwaresForThingRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegisteredUIComponentsInNamespaceRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUIComponentToNamespaceRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUIComponentToNamespace(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUIComponentToNamespaceRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUIComponentFromNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUIComponentInNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUIComponentInNamespaceRequestWithBody(c.Server, namespace, componentUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUIComponentInNamespaceRequest(c.Server, namespace, componentUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUITilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUUIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultVoiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpretersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextByDefaultInterpreterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpreterByUIDRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextWithBody(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTextToSpeechRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRootRequest generates requests for GetRoot
func NewGetRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonsRequest generates requests for GetAddons
func NewGetAddonsRequest(server string, params *GetAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAddonTypesRequest generates requests for GetAddonTypes
func NewGetAddonTypesRequest(server string, params *GetAddonTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAddonServicesRequest generates requests for GetAddonServices
func NewGetAddonServicesRequest(server string, params *GetAddonServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInstallAddonFromURLRequest generates requests for InstallAddonFromURL
func NewInstallAddonFromURLRequest(server string, url_ string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "url", runtime.ParamLocationPath, url_)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/url/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonByIdRequest generates requests for GetAddonById
func NewGetAddonByIdRequest(server string, addonId string, params *GetAddonByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInstallAddonByIdRequest generates requests for InstallAddonById
func NewInstallAddonByIdRequest(server string, addonId string, params *InstallAddonByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallAddonRequest generates requests for UninstallAddon
func NewUninstallAddonRequest(server string, addonId string, params *UninstallAddonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/uninstall", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioDefaultSinkRequest generates requests for GetAudioDefaultSink
func NewGetAudioDefaultSinkRequest(server string, params *GetAudioDefaultSinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioDefaultSourceRequest generates requests for GetAudioDefaultSource
func NewGetAudioDefaultSourceRequest(server string, params *GetAudioDefaultSourceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsource")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioSinksRequest generates requests for GetAudioSinks
func NewGetAudioSinksRequest(server string, params *GetAudioSinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioSourcesRequest generates requests for GetAudioSources
func NewGetAudioSourcesRequest(server string, params *GetAudioSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetApiTokensRequest generates requests for GetApiTokens
func NewGetApiTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveApiTokenRequest generates requests for RemoveApiToken
func NewRemoveApiTokenRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSessionRequestWithBody generates requests for DeleteSession with any type of body
func NewDeleteSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSessionsForCurrentUserRequest generates requests for GetSessionsForCurrentUser
func NewGetSessionsForCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, params *GetOAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UseCookie != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useCookie", runtime.ParamLocationQuery, *params.UseCookie); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBindingsRequest generates requests for GetBindings
func NewGetBindingsRequest(server string, params *GetBindingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetBindingConfigurationRequest generates requests for GetBindingConfiguration
func NewGetBindingConfigurationRequest(server string, bindingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBindingConfigurationRequest calls the generic UpdateBindingConfiguration builder with application/json body
func NewUpdateBindingConfigurationRequest(server string, bindingId string, body UpdateBindingConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBindingConfigurationRequestWithBody(server, bindingId, "application/json", bodyReader)
}

// NewUpdateBindingConfigurationRequestWithBody generates requests for UpdateBindingConfiguration with any type of body
func NewUpdateBindingConfigurationRequestWithBody(server string, bindingId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelTypesRequest generates requests for GetChannelTypes
func NewGetChannelTypesRequest(server string, params *GetChannelTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetChannelTypeByUIDRequest generates requests for GetChannelTypeByUID
func NewGetChannelTypeByUIDRequest(server string, channelTypeUID string, params *GetChannelTypeByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetLinkableItemTypesByChannelTypeUIDRequest generates requests for GetLinkableItemTypesByChannelTypeUID
func NewGetLinkableItemTypesByChannelTypeUIDRequest(server string, channelTypeUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s/linkableItemTypes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigDescriptionsRequest generates requests for GetConfigDescriptions
func NewGetConfigDescriptionsRequest(server string, params *GetConfigDescriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Scheme != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheme", runtime.ParamLocationQuery, *params.Scheme); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetConfigDescriptionByURIRequest generates requests for GetConfigDescriptionByURI
func NewGetConfigDescriptionByURIRequest(server string, uri string, params *GetConfigDescriptionByURIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uri", runtime.ParamLocationPath, uri)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetBindingsWithDiscoverySupportRequest generates requests for GetBindingsWithDiscoverySupport
func NewGetBindingsWithDiscoverySupportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScanRequest generates requests for Scan
func NewScanRequest(server string, bindingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/bindings/%s/scan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, params *GetEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Topics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitNewStateTackerRequest generates requests for InitNewStateTacker
func NewInitNewStateTackerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemListForStateUpdatesRequestWithBody generates requests for UpdateItemListForStateUpdates with any type of body
func NewUpdateItemListForStateUpdatesRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGalleryWidgetListRequest generates requests for GetGalleryWidgetList
func NewGetGalleryWidgetListRequest(server string, galleryName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, galleryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/habpanel/gallery/%s/widgets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGalleryWidgetsItemRequest generates requests for GetGalleryWidgetsItem
func NewGetGalleryWidgetsItemRequest(server string, galleryName string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, galleryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/habpanel/gallery/%s/widgets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIconSetsRequest generates requests for GetIconSets
func NewGetIconSetsRequest(server string, params *GetIconSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iconsets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetDiscoveredInboxItemsRequest generates requests for GetDiscoveredInboxItems
func NewGetDiscoveredInboxItemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveItemFromInboxRequest generates requests for RemoveItemFromInbox
func NewRemoveItemFromInboxRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveInboxItemByIdRequestWithBody generates requests for ApproveInboxItemById with any type of body
func NewApproveInboxItemByIdRequestWithBody(server string, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewThingId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newThingId", runtime.ParamLocationQuery, *params.NewThingId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewFlagInboxItemAsIgnoredRequest generates requests for FlagInboxItemAsIgnored
func NewFlagInboxItemAsIgnoredRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/ignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveIgnoreFlagOnInboxItemRequest generates requests for RemoveIgnoreFlagOnInboxItem
func NewRemoveIgnoreFlagOnInboxItemRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/unignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemsRequest generates requests for GetItems
func NewGetItemsRequest(server string, params *GetItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Recursive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewAddOrUpdateItemsInRegistryRequest calls the generic AddOrUpdateItemsInRegistry builder with application/json body
func NewAddOrUpdateItemsInRegistryRequest(server string, body AddOrUpdateItemsInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemsInRegistryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrUpdateItemsInRegistryRequestWithBody generates requests for AddOrUpdateItemsInRegistry with any type of body
func NewAddOrUpdateItemsInRegistryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMemberFromGroupItemRequest generates requests for RemoveMemberFromGroupItem
func NewRemoveMemberFromGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMemberToGroupItemRequest generates requests for AddMemberToGroupItem
func NewAddMemberToGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveItemFromRegistryRequest generates requests for RemoveItemFromRegistry
func NewRemoveItemFromRegistryRequest(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemByNameRequest generates requests for GetItemByName
func NewGetItemByNameRequest(server string, itemname string, params *GetItemByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Recursive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewSendItemCommandRequestWithBody generates requests for SendItemCommand with any type of body
func NewSendItemCommandRequestWithBody(server string, itemname string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOrUpdateItemInRegistryRequest calls the generic AddOrUpdateItemInRegistry builder with application/json body
func NewAddOrUpdateItemInRegistryRequest(server string, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemInRegistryRequestWithBody(server, itemname, params, "application/json", bodyReader)
}

// NewAddOrUpdateItemInRegistryRequestWithBody generates requests for AddOrUpdateItemInRegistry with any type of body
func NewAddOrUpdateItemInRegistryRequestWithBody(server string, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveMetadataFromItemRequest generates requests for RemoveMetadataFromItem
func NewRemoveMetadataFromItemRequest(server string, itemname string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMetadataToItemRequest calls the generic AddMetadataToItem builder with application/json body
func NewAddMetadataToItemRequest(server string, itemname string, namespace string, body AddMetadataToItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMetadataToItemRequestWithBody(server, itemname, namespace, "application/json", bodyReader)
}

// NewAddMetadataToItemRequestWithBody generates requests for AddMetadataToItem with any type of body
func NewAddMetadataToItemRequestWithBody(server string, itemname string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetItemStateRequest generates requests for GetItemState
func NewGetItemStateRequest(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemStateRequestWithBody generates requests for UpdateItemState with any type of body
func NewUpdateItemStateRequestWithBody(server string, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveTagFromItemRequest generates requests for RemoveTagFromItem
func NewRemoveTagFromItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTagToItemRequest generates requests for AddTagToItem
func NewAddTagToItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinksRequest generates requests for GetItemLinks
func NewGetItemLinksRequest(server string, params *GetItemLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ChannelUID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelUID", runtime.ParamLocationQuery, *params.ChannelUID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemName", runtime.ParamLocationQuery, *params.ItemName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkItemFromChannelRequest generates requests for UnlinkItemFromChannel
func NewUnlinkItemFromChannelRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinkRequest generates requests for GetItemLink
func NewGetItemLinkRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkItemToChannelRequest calls the generic LinkItemToChannel builder with application/json body
func NewLinkItemToChannelRequest(server string, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkItemToChannelRequestWithBody(server, itemName, channelUID, "application/json", bodyReader)
}

// NewLinkItemToChannelRequestWithBody generates requests for LinkItemToChannel with any type of body
func NewLinkItemToChannelRequestWithBody(server string, itemName string, channelUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetModuleTypesRequest generates requests for GetModuleTypes
func NewGetModuleTypesRequest(server string, params *GetModuleTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetModuleTypeByIdRequest generates requests for GetModuleTypeById
func NewGetModuleTypeByIdRequest(server string, moduleTypeUID string, params *GetModuleTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "moduleTypeUID", runtime.ParamLocationPath, moduleTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetPersistenceServicesRequest generates requests for GetPersistenceServices
func NewGetPersistenceServicesRequest(server string, params *GetPersistenceServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetItemsForPersistenceServiceRequest generates requests for GetItemsForPersistenceService
func NewGetItemsForPersistenceServiceRequest(server string, params *GetItemsForPersistenceServiceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemFromPersistenceServiceRequest generates requests for DeleteItemFromPersistenceService
func NewDeleteItemFromPersistenceServiceRequest(server string, itemname string, params *DeleteItemFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, params.ServiceId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, params.Starttime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, params.Endtime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemDataFromPersistenceServiceRequest generates requests for GetItemDataFromPersistenceService
func NewGetItemDataFromPersistenceServiceRequest(server string, itemname string, params *GetItemDataFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Starttime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, *params.Starttime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Endtime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, *params.Endtime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pagelength != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagelength", runtime.ParamLocationQuery, *params.Pagelength); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Boundary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boundary", runtime.ParamLocationQuery, *params.Boundary); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreItemDataInPersistenceServiceRequest generates requests for StoreItemDataInPersistenceService
func NewStoreItemDataInPersistenceServiceRequest(server string, itemname string, params *StoreItemDataInPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, params.Time); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileTypesRequest generates requests for GetProfileTypes
func NewGetProfileTypesRequest(server string, params *GetProfileTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ChannelTypeUID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelTypeUID", runtime.ParamLocationQuery, *params.ChannelTypeUID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemType", runtime.ParamLocationQuery, *params.ItemType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScheduleRuleSimulationsRequest generates requests for GetScheduleRuleSimulations
func NewGetScheduleRuleSimulationsRequest(server string, params *GetScheduleRuleSimulationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/schedule/simulations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Until != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleByIdRequest generates requests for GetRuleById
func NewGetRuleByIdRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, ruleUID string, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRuleActionsRequest generates requests for GetRuleActions
func NewGetRuleActionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConditionsRequest generates requests for GetRuleConditions
func NewGetRuleConditionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConfigurationRequest generates requests for GetRuleConfiguration
func NewGetRuleConfigurationRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleConfigurationRequest calls the generic UpdateRuleConfiguration builder with application/json body
func NewUpdateRuleConfigurationRequest(server string, ruleUID string, body UpdateRuleConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleConfigurationRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleConfigurationRequestWithBody generates requests for UpdateRuleConfiguration with any type of body
func NewUpdateRuleConfigurationRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableRuleRequestWithBody generates requests for EnableRule with any type of body
func NewEnableRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunRuleNowRequest generates requests for RunRuleNow
func NewRunRuleNowRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/runnow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleTriggersRequest generates requests for GetRuleTriggers
func NewGetRuleTriggersRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleByIdRequest generates requests for GetRuleModuleById
func NewGetRuleModuleByIdRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigRequest generates requests for GetRuleModuleConfig
func NewGetRuleModuleConfigRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigParameterRequest generates requests for GetRuleModuleConfigParameter
func NewGetRuleModuleConfigParameterRequest(server string, ruleUID string, moduleCategory string, id string, param string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRuleModuleConfigParameterRequestWithBody generates requests for SetRuleModuleConfigParameter with any type of body
func NewSetRuleModuleConfigParameterRequestWithBody(server string, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string, params *GetServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetServicesByIdRequest generates requests for GetServicesById
func NewGetServicesByIdRequest(server string, serviceId string, params *GetServicesByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewDeleteServiceConfigRequest generates requests for DeleteServiceConfig
func NewDeleteServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceConfigRequest generates requests for GetServiceConfig
func NewGetServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceConfigRequest calls the generic UpdateServiceConfig builder with application/json body
func NewUpdateServiceConfigRequest(server string, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceConfigRequestWithBody(server, serviceId, params, "application/json", bodyReader)
}

// NewUpdateServiceConfigRequestWithBody generates requests for UpdateServiceConfig with any type of body
func NewUpdateServiceConfigRequestWithBody(server string, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetServiceContextRequest generates requests for GetServiceContext
func NewGetServiceContextRequest(server string, serviceId string, params *GetServiceContextParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/contexts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetSitemapsRequest generates requests for GetSitemaps
func NewGetSitemapsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSitemapEventSubscriptionRequest generates requests for CreateSitemapEventSubscription
func NewCreateSitemapEventSubscriptionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapEventsRequest generates requests for GetSitemapEvents
func NewGetSitemapEventsRequest(server string, subscriptionid string, params *GetSitemapEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionid", runtime.ParamLocationPath, subscriptionid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sitemap != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitemap", runtime.ParamLocationQuery, *params.Sitemap); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pageid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageid", runtime.ParamLocationQuery, *params.Pageid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapByNameRequest generates requests for GetSitemapByName
func NewGetSitemapByNameRequest(server string, sitemapname string, params *GetSitemapByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Jsoncallback != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsoncallback", runtime.ParamLocationQuery, *params.Jsoncallback); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewPollDataForSitemapRequest generates requests for PollDataForSitemap
func NewPollDataForSitemapRequest(server string, sitemapname string, pageid string, params *PollDataForSitemapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pageid", runtime.ParamLocationPath, pageid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Subscriptionid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionid", runtime.ParamLocationQuery, *params.Subscriptionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetSystemInformationRequest generates requests for GetSystemInformation
func NewGetSystemInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systeminfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string, params *GetTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetTemplateByIdRequest generates requests for GetTemplateById
func NewGetTemplateByIdRequest(server string, templateUID string, params *GetTemplateByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateUID", runtime.ParamLocationPath, templateUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingTypesRequest generates requests for GetThingTypes
func NewGetThingTypesRequest(server string, params *GetThingTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BindingId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bindingId", runtime.ParamLocationQuery, *params.BindingId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingTypeByIdRequest generates requests for GetThingTypeById
func NewGetThingTypeByIdRequest(server string, thingTypeUID string, params *GetThingTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingTypeUID", runtime.ParamLocationPath, thingTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingsRequest generates requests for GetThings
func NewGetThingsRequest(server string, params *GetThingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewCreateThingInRegistryRequest calls the generic CreateThingInRegistry builder with application/json body
func NewCreateThingInRegistryRequest(server string, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateThingInRegistryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateThingInRegistryRequestWithBody generates requests for CreateThingInRegistry with any type of body
func NewCreateThingInRegistryRequestWithBody(server string, params *CreateThingInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveThingByIdRequest generates requests for RemoveThingById
func NewRemoveThingByIdRequest(server string, thingUID string, params *RemoveThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingByIdRequest generates requests for GetThingById
func NewGetThingByIdRequest(server string, thingUID string, params *GetThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingRequest calls the generic UpdateThing builder with application/json body
func NewUpdateThingRequest(server string, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingRequestWithBody generates requests for UpdateThing with any type of body
func NewUpdateThingRequestWithBody(server string, thingUID string, params *UpdateThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingConfigRequest calls the generic UpdateThingConfig builder with application/json body
func NewUpdateThingConfigRequest(server string, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingConfigRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingConfigRequestWithBody generates requests for UpdateThingConfig with any type of body
func NewUpdateThingConfigRequestWithBody(server string, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingConfigStatusRequest generates requests for GetThingConfigStatus
func NewGetThingConfigStatusRequest(server string, thingUID string, params *GetThingConfigStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewEnableThingRequestWithBody generates requests for EnableThing with any type of body
func NewEnableThingRequestWithBody(server string, thingUID string, params *EnableThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingFirmwareStatusRequest generates requests for GetThingFirmwareStatus
func NewGetThingFirmwareStatusRequest(server string, thingUID string, params *GetThingFirmwareStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingFirmwareRequest generates requests for UpdateThingFirmware
func NewUpdateThingFirmwareRequest(server string, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "firmwareVersion", runtime.ParamLocationPath, firmwareVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAvailableFirmwaresForThingRequest generates requests for GetAvailableFirmwaresForThing
func NewGetAvailableFirmwaresForThingRequest(server string, thingUID string, params *GetAvailableFirmwaresForThingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmwares", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingStatusRequest generates requests for GetThingStatus
func NewGetThingStatusRequest(server string, thingUID string, params *GetThingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetRegisteredUIComponentsInNamespaceRequest generates requests for GetRegisteredUIComponentsInNamespace
func NewGetRegisteredUIComponentsInNamespaceRequest(server string, namespace string, params *GetRegisteredUIComponentsInNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUIComponentToNamespaceRequest calls the generic AddUIComponentToNamespace builder with application/json body
func NewAddUIComponentToNamespaceRequest(server string, namespace string, body AddUIComponentToNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUIComponentToNamespaceRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewAddUIComponentToNamespaceRequestWithBody generates requests for AddUIComponentToNamespace with any type of body
func NewAddUIComponentToNamespaceRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUIComponentFromNamespaceRequest generates requests for RemoveUIComponentFromNamespace
func NewRemoveUIComponentFromNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUIComponentInNamespaceRequest generates requests for GetUIComponentInNamespace
func NewGetUIComponentInNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUIComponentInNamespaceRequest calls the generic UpdateUIComponentInNamespace builder with application/json body
func NewUpdateUIComponentInNamespaceRequest(server string, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUIComponentInNamespaceRequestWithBody(server, namespace, componentUID, "application/json", bodyReader)
}

// NewUpdateUIComponentInNamespaceRequestWithBody generates requests for UpdateUIComponentInNamespace with any type of body
func NewUpdateUIComponentInNamespaceRequestWithBody(server string, namespace string, componentUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUITilesRequest generates requests for GetUITiles
func NewGetUITilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/tiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUUIDRequest generates requests for GetUUID
func NewGetUUIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uuid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultVoiceRequest generates requests for GetDefaultVoice
func NewGetDefaultVoiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/defaultvoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceInterpretersRequest generates requests for GetVoiceInterpreters
func NewGetVoiceInterpretersRequest(server string, params *GetVoiceInterpretersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInterpretTextByDefaultInterpreterRequestWithBody generates requests for InterpretTextByDefaultInterpreter with any type of body
func NewInterpretTextByDefaultInterpreterRequestWithBody(server string, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetVoiceInterpreterByUIDRequest generates requests for GetVoiceInterpreterByUID
func NewGetVoiceInterpreterByUIDRequest(server string, id string, params *GetVoiceInterpreterByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInterpretTextRequestWithBody generates requests for InterpretText with any type of body
func NewInterpretTextRequestWithBody(server string, id string, params *InterpretTextParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewTextToSpeechRequestWithBody generates requests for TextToSpeech with any type of body
func NewTextToSpeechRequestWithBody(server string, params *TextToSpeechParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/say")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Voiceid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voiceid", runtime.ParamLocationQuery, *params.Voiceid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sinkid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinkid", runtime.ParamLocationQuery, *params.Sinkid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVoicesRequest generates requests for GetVoices
func NewGetVoicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/voices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetRoot request
	GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error)

	// GetAddons request
	GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error)

	// GetAddonTypes request
	GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error)

	// GetAddonServices request
	GetAddonServicesWithResponse(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*GetAddonServicesResponse, error)

	// InstallAddonFromURL request
	InstallAddonFromURLWithResponse(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*InstallAddonFromURLResponse, error)

	// GetAddonById request
	GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error)

	// InstallAddonById request
	InstallAddonByIdWithResponse(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error)

	// UninstallAddon request
	UninstallAddonWithResponse(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error)

	// GetAudioDefaultSink request
	GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error)

	// GetAudioDefaultSource request
	GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error)

	// GetAudioSinks request
	GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error)

	// GetAudioSources request
	GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error)

	// GetApiTokens request
	GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error)

	// RemoveApiToken request
	RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error)

	// DeleteSession request with any body
	DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error)

	// GetSessionsForCurrentUser request
	GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// GetBindings request
	GetBindingsWithResponse(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*GetBindingsResponse, error)

	// GetBindingConfiguration request
	GetBindingConfigurationWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*GetBindingConfigurationResponse, error)

	// UpdateBindingConfiguration request with any body
	UpdateBindingConfigurationWithBodyWithResponse(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error)

	UpdateBindingConfigurationWithResponse(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error)

	// GetChannelTypes request
	GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error)

	// GetChannelTypeByUID request
	GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error)

	// GetLinkableItemTypesByChannelTypeUID request
	GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error)

	// GetConfigDescriptions request
	GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error)

	// GetConfigDescriptionByURI request
	GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error)

	// GetBindingsWithDiscoverySupport request
	GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error)

	// Scan request
	ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error)

	// GetEvents request
	GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)

	// InitNewStateTacker request
	InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error)

	// UpdateItemListForStateUpdates request with any body
	UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error)

	// GetGalleryWidgetList request
	GetGalleryWidgetListWithResponse(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetListResponse, error)

	// GetGalleryWidgetsItem request
	GetGalleryWidgetsItemWithResponse(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetsItemResponse, error)

	// GetIconSets request
	GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error)

	// GetDiscoveredInboxItems request
	GetDiscoveredInboxItemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error)

	// RemoveItemFromInbox request
	RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error)

	// ApproveInboxItemById request with any body
	ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error)

	// FlagInboxItemAsIgnored request
	FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error)

	// RemoveIgnoreFlagOnInboxItem request
	RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error)

	// GetItems request
	GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error)

	// AddOrUpdateItemsInRegistry request with any body
	AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	// RemoveMemberFromGroupItem request
	RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error)

	// AddMemberToGroupItem request
	AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error)

	// RemoveItemFromRegistry request
	RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error)

	// GetItemByName request
	GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error)

	// SendItemCommand request with any body
	SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error)

	// AddOrUpdateItemInRegistry request with any body
	AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	// RemoveMetadataFromItem request
	RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error)

	// AddMetadataToItem request with any body
	AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	// GetItemState request
	GetItemStateWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemStateResponse, error)

	// UpdateItemState request with any body
	UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error)

	// RemoveTagFromItem request
	RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error)

	// AddTagToItem request
	AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error)

	// GetItemLinks request
	GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error)

	// UnlinkItemFromChannel request
	UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error)

	// GetItemLink request
	GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error)

	// LinkItemToChannel request with any body
	LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error)

	LinkItemToChannelWithResponse(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error)

	// GetModuleTypes request
	GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error)

	// GetModuleTypeById request
	GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error)

	// GetPersistenceServices request
	GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error)

	// GetItemsForPersistenceService request
	GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error)

	// DeleteItemFromPersistenceService request
	DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error)

	// GetItemDataFromPersistenceService request
	GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error)

	// StoreItemDataInPersistenceService request
	StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error)

	// GetProfileTypes request
	GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error)

	// GetRules request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// CreateRule request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// GetScheduleRuleSimulations request
	GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error)

	// DeleteRule request
	DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleById request
	GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error)

	// UpdateRule request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// GetRuleActions request
	GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error)

	// GetRuleConditions request
	GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error)

	// GetRuleConfiguration request
	GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error)

	// UpdateRuleConfiguration request with any body
	UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	// EnableRule request with any body
	EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error)

	// RunRuleNow request
	RunRuleNowWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*RunRuleNowResponse, error)

	// GetRuleTriggers request
	GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error)

	// GetRuleModuleById request
	GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error)

	// GetRuleModuleConfig request
	GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error)

	// GetRuleModuleConfigParameter request
	GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error)

	// SetRuleModuleConfigParameter request with any body
	SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error)

	// GetServices request
	GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// GetServicesById request
	GetServicesByIdWithResponse(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error)

	// DeleteServiceConfig request
	DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error)

	// GetServiceConfig request
	GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error)

	// UpdateServiceConfig request with any body
	UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	// GetServiceContext request
	GetServiceContextWithResponse(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error)

	// GetSitemaps request
	GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error)

	// CreateSitemapEventSubscription request
	CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error)

	// GetSitemapEvents request
	GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error)

	// GetSitemapByName request
	GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error)

	// PollDataForSitemap request
	PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error)

	// GetSystemInformation request
	GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error)

	// GetTemplates request
	GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error)

	// GetTemplateById request
	GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error)

	// GetThingTypes request
	GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error)

	// GetThingTypeById request
	GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error)

	// GetThings request
	GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error)

	// CreateThingInRegistry request with any body
	CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	// RemoveThingById request
	RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error)

	// GetThingById request
	GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error)

	// UpdateThing request with any body
	UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	// UpdateThingConfig request with any body
	UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	// GetThingConfigStatus request
	GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error)

	// EnableThing request with any body
	EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error)

	// GetThingFirmwareStatus request
	GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error)

	// UpdateThingFirmware request
	UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error)

	// GetAvailableFirmwaresForThing request
	GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error)

	// GetThingStatus request
	GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error)

	// GetRegisteredUIComponentsInNamespace request
	GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error)

	// AddUIComponentToNamespace request with any body
	AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error)

	AddUIComponentToNamespaceWithResponse(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error)

	// RemoveUIComponentFromNamespace request
	RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error)

	// GetUIComponentInNamespace request
	GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error)

	// UpdateUIComponentInNamespace request with any body
	UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error)

	UpdateUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error)

	// GetUITiles request
	GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error)

	// GetUUID request
	GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error)

	// GetDefaultVoice request
	GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error)

	// GetVoiceInterpreters request
	GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error)

	// InterpretTextByDefaultInterpreter request with any body
	InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error)

	// GetVoiceInterpreterByUID request
	GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error)

	// InterpretText request with any body
	InterpretTextWithBodyWithResponse(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error)

	// TextToSpeech request with any body
	TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error)

	// GetVoices request
	GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error)
}

type GetRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootBean
}

// Status returns HTTPResponse.Status
func (r GetRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddonType
}

// Status returns HTTPResponse.Status
func (r GetAddonTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddonType
}

// Status returns HTTPResponse.Status
func (r GetAddonServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAddonFromURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallAddonFromURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAddonFromURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UninstallAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserApiTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveApiTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveApiTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveApiTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionsForCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserSessionDTO
}

// Status returns HTTPResponse.Status
func (r GetSessionsForCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionsForCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseDTO
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BindingInfoDTO
}

// Status returns HTTPResponse.Status
func (r GetBindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetBindingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBindingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateBindingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBindingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypeByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypeByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypeByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkableItemTypesByChannelTypeUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetLinkableItemTypesByChannelTypeUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkableItemTypesByChannelTypeUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionByURIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionByURIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionByURIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingsWithDiscoverySupportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetBindingsWithDiscoverySupportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingsWithDiscoverySupportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitNewStateTackerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InitNewStateTackerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitNewStateTackerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemListForStateUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemListForStateUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemListForStateUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGalleryWidgetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GalleryWidgetsListItem
}

// Status returns HTTPResponse.Status
func (r GetGalleryWidgetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGalleryWidgetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGalleryWidgetsItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GalleryItem
}

// Status returns HTTPResponse.Status
func (r GetGalleryWidgetsItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGalleryWidgetsItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIconSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IconSet
}

// Status returns HTTPResponse.Status
func (r GetIconSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIconSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscoveredInboxItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiscoveryResultDTO
}

// Status returns HTTPResponse.Status
func (r GetDiscoveredInboxItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscoveredInboxItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromInboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromInboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromInboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveInboxItemByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApproveInboxItemByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveInboxItemByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FlagInboxItemAsIgnoredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FlagInboxItemAsIgnoredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FlagInboxItemAsIgnoredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveIgnoreFlagOnInboxItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveIgnoreFlagOnInboxItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveIgnoreFlagOnInboxItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemsInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemsInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemsInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMemberFromGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMemberFromGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMemberFromGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMemberToGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMemberToGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMemberToGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendItemCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendItemCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendItemCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMetadataFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMetadataFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMetadataFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMetadataToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMetadataToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMetadataToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetItemStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveTagFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTagToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddTagToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTagToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemChannelLinkDTO
}

// Status returns HTTPResponse.Status
func (r GetItemLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkItemFromChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkItemFromChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkItemFromChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedItemChannelLinkDTO
}

// Status returns HTTPResponse.Status
func (r GetItemLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkItemToChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkItemToChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkItemToChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetPersistenceServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsForPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceItemInfo
}

// Status returns HTTPResponse.Status
func (r GetItemsForPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsForPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteItemFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemDataFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemHistoryDTO
}

// Status returns HTTPResponse.Status
func (r GetItemDataFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemDataFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreItemDataInPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StoreItemDataInPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreItemDataInPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProfileTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetProfileTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleRuleSimulationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RuleExecution
}

// Status returns HTTPResponse.Status
func (r GetScheduleRuleSimulationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleRuleSimulationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConditionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunRuleNowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunRuleNowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunRuleNowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TriggerDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServiceContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSitemapEventSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSitemapEventSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSitemapEventSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSitemapEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollDataForSitemapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageDTO
}

// Status returns HTTPResponse.Status
func (r PollDataForSitemapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollDataForSitemapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfoBean
}

// Status returns HTTPResponse.Status
func (r GetSystemInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StrippedThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateThingInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateThingInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateThingInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingConfigStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigStatusMessage
}

// Status returns HTTPResponse.Status
func (r GetThingConfigStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingConfigStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingFirmwareStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetThingFirmwareStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingFirmwareStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingFirmwareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingFirmwareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingFirmwareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableFirmwaresForThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FirmwareDTO
}

// Status returns HTTPResponse.Status
func (r GetAvailableFirmwaresForThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableFirmwaresForThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingStatusInfo
}

// Status returns HTTPResponse.Status
func (r GetThingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegisteredUIComponentsInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetRegisteredUIComponentsInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegisteredUIComponentsInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUIComponentToNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r AddUIComponentToNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUIComponentToNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUIComponentFromNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUIComponentFromNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUIComponentFromNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r UpdateUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUITilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TileDTO
}

// Status returns HTTPResponse.Status
func (r GetUITilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUITilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultVoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetDefaultVoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultVoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpretersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpretersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpretersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextByDefaultInterpreterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextByDefaultInterpreterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextByDefaultInterpreterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpreterByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpreterByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpreterByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TextToSpeechResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TextToSpeechResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TextToSpeechResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetVoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetRootWithResponse request returning *GetRootResponse
func (c *ClientWithResponses) GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error) {
	rsp, err := c.GetRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootResponse(rsp)
}

// GetAddonsWithResponse request returning *GetAddonsResponse
func (c *ClientWithResponses) GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error) {
	rsp, err := c.GetAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonsResponse(rsp)
}

// GetAddonTypesWithResponse request returning *GetAddonTypesResponse
func (c *ClientWithResponses) GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error) {
	rsp, err := c.GetAddonTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonTypesResponse(rsp)
}

// GetAddonServicesWithResponse request returning *GetAddonServicesResponse
func (c *ClientWithResponses) GetAddonServicesWithResponse(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*GetAddonServicesResponse, error) {
	rsp, err := c.GetAddonServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonServicesResponse(rsp)
}

// InstallAddonFromURLWithResponse request returning *InstallAddonFromURLResponse
func (c *ClientWithResponses) InstallAddonFromURLWithResponse(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*InstallAddonFromURLResponse, error) {
	rsp, err := c.InstallAddonFromURL(ctx, url, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAddonFromURLResponse(rsp)
}

// GetAddonByIdWithResponse request returning *GetAddonByIdResponse
func (c *ClientWithResponses) GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error) {
	rsp, err := c.GetAddonById(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonByIdResponse(rsp)
}

// InstallAddonByIdWithResponse request returning *InstallAddonByIdResponse
func (c *ClientWithResponses) InstallAddonByIdWithResponse(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error) {
	rsp, err := c.InstallAddonById(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAddonByIdResponse(rsp)
}

// UninstallAddonWithResponse request returning *UninstallAddonResponse
func (c *ClientWithResponses) UninstallAddonWithResponse(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error) {
	rsp, err := c.UninstallAddon(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAddonResponse(rsp)
}

// GetAudioDefaultSinkWithResponse request returning *GetAudioDefaultSinkResponse
func (c *ClientWithResponses) GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error) {
	rsp, err := c.GetAudioDefaultSink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSinkResponse(rsp)
}

// GetAudioDefaultSourceWithResponse request returning *GetAudioDefaultSourceResponse
func (c *ClientWithResponses) GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error) {
	rsp, err := c.GetAudioDefaultSource(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSourceResponse(rsp)
}

// GetAudioSinksWithResponse request returning *GetAudioSinksResponse
func (c *ClientWithResponses) GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error) {
	rsp, err := c.GetAudioSinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSinksResponse(rsp)
}

// GetAudioSourcesWithResponse request returning *GetAudioSourcesResponse
func (c *ClientWithResponses) GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error) {
	rsp, err := c.GetAudioSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSourcesResponse(rsp)
}

// GetApiTokensWithResponse request returning *GetApiTokensResponse
func (c *ClientWithResponses) GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error) {
	rsp, err := c.GetApiTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiTokensResponse(rsp)
}

// RemoveApiTokenWithResponse request returning *RemoveApiTokenResponse
func (c *ClientWithResponses) RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error) {
	rsp, err := c.RemoveApiToken(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveApiTokenResponse(rsp)
}

// DeleteSessionWithBodyWithResponse request with arbitrary body returning *DeleteSessionResponse
func (c *ClientWithResponses) DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error) {
	rsp, err := c.DeleteSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionResponse(rsp)
}

// GetSessionsForCurrentUserWithResponse request returning *GetSessionsForCurrentUserResponse
func (c *ClientWithResponses) GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error) {
	rsp, err := c.GetSessionsForCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionsForCurrentUserResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// GetBindingsWithResponse request returning *GetBindingsResponse
func (c *ClientWithResponses) GetBindingsWithResponse(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*GetBindingsResponse, error) {
	rsp, err := c.GetBindings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingsResponse(rsp)
}

// GetBindingConfigurationWithResponse request returning *GetBindingConfigurationResponse
func (c *ClientWithResponses) GetBindingConfigurationWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*GetBindingConfigurationResponse, error) {
	rsp, err := c.GetBindingConfiguration(ctx, bindingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingConfigurationResponse(rsp)
}

// UpdateBindingConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateBindingConfigurationResponse
func (c *ClientWithResponses) UpdateBindingConfigurationWithBodyWithResponse(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error) {
	rsp, err := c.UpdateBindingConfigurationWithBody(ctx, bindingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBindingConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateBindingConfigurationWithResponse(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error) {
	rsp, err := c.UpdateBindingConfiguration(ctx, bindingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBindingConfigurationResponse(rsp)
}

// GetChannelTypesWithResponse request returning *GetChannelTypesResponse
func (c *ClientWithResponses) GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error) {
	rsp, err := c.GetChannelTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypesResponse(rsp)
}

// GetChannelTypeByUIDWithResponse request returning *GetChannelTypeByUIDResponse
func (c *ClientWithResponses) GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error) {
	rsp, err := c.GetChannelTypeByUID(ctx, channelTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypeByUIDResponse(rsp)
}

// GetLinkableItemTypesByChannelTypeUIDWithResponse request returning *GetLinkableItemTypesByChannelTypeUIDResponse
func (c *ClientWithResponses) GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	rsp, err := c.GetLinkableItemTypesByChannelTypeUID(ctx, channelTypeUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp)
}

// GetConfigDescriptionsWithResponse request returning *GetConfigDescriptionsResponse
func (c *ClientWithResponses) GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error) {
	rsp, err := c.GetConfigDescriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionsResponse(rsp)
}

// GetConfigDescriptionByURIWithResponse request returning *GetConfigDescriptionByURIResponse
func (c *ClientWithResponses) GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error) {
	rsp, err := c.GetConfigDescriptionByURI(ctx, uri, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionByURIResponse(rsp)
}

// GetBindingsWithDiscoverySupportWithResponse request returning *GetBindingsWithDiscoverySupportResponse
func (c *ClientWithResponses) GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error) {
	rsp, err := c.GetBindingsWithDiscoverySupport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingsWithDiscoverySupportResponse(rsp)
}

// ScanWithResponse request returning *ScanResponse
func (c *ClientWithResponses) ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error) {
	rsp, err := c.Scan(ctx, bindingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// InitNewStateTackerWithResponse request returning *InitNewStateTackerResponse
func (c *ClientWithResponses) InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error) {
	rsp, err := c.InitNewStateTacker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitNewStateTackerResponse(rsp)
}

// UpdateItemListForStateUpdatesWithBodyWithResponse request with arbitrary body returning *UpdateItemListForStateUpdatesResponse
func (c *ClientWithResponses) UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error) {
	rsp, err := c.UpdateItemListForStateUpdatesWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemListForStateUpdatesResponse(rsp)
}

// GetGalleryWidgetListWithResponse request returning *GetGalleryWidgetListResponse
func (c *ClientWithResponses) GetGalleryWidgetListWithResponse(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetListResponse, error) {
	rsp, err := c.GetGalleryWidgetList(ctx, galleryName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGalleryWidgetListResponse(rsp)
}

// GetGalleryWidgetsItemWithResponse request returning *GetGalleryWidgetsItemResponse
func (c *ClientWithResponses) GetGalleryWidgetsItemWithResponse(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetsItemResponse, error) {
	rsp, err := c.GetGalleryWidgetsItem(ctx, galleryName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGalleryWidgetsItemResponse(rsp)
}

// GetIconSetsWithResponse request returning *GetIconSetsResponse
func (c *ClientWithResponses) GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error) {
	rsp, err := c.GetIconSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIconSetsResponse(rsp)
}

// GetDiscoveredInboxItemsWithResponse request returning *GetDiscoveredInboxItemsResponse
func (c *ClientWithResponses) GetDiscoveredInboxItemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error) {
	rsp, err := c.GetDiscoveredInboxItems(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscoveredInboxItemsResponse(rsp)
}

// RemoveItemFromInboxWithResponse request returning *RemoveItemFromInboxResponse
func (c *ClientWithResponses) RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error) {
	rsp, err := c.RemoveItemFromInbox(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromInboxResponse(rsp)
}

// ApproveInboxItemByIdWithBodyWithResponse request with arbitrary body returning *ApproveInboxItemByIdResponse
func (c *ClientWithResponses) ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error) {
	rsp, err := c.ApproveInboxItemByIdWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveInboxItemByIdResponse(rsp)
}

// FlagInboxItemAsIgnoredWithResponse request returning *FlagInboxItemAsIgnoredResponse
func (c *ClientWithResponses) FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error) {
	rsp, err := c.FlagInboxItemAsIgnored(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFlagInboxItemAsIgnoredResponse(rsp)
}

// RemoveIgnoreFlagOnInboxItemWithResponse request returning *RemoveIgnoreFlagOnInboxItemResponse
func (c *ClientWithResponses) RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	rsp, err := c.RemoveIgnoreFlagOnInboxItem(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveIgnoreFlagOnInboxItemResponse(rsp)
}

// GetItemsWithResponse request returning *GetItemsResponse
func (c *ClientWithResponses) GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error) {
	rsp, err := c.GetItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsResponse(rsp)
}

// AddOrUpdateItemsInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemsInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

// RemoveMemberFromGroupItemWithResponse request returning *RemoveMemberFromGroupItemResponse
func (c *ClientWithResponses) RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error) {
	rsp, err := c.RemoveMemberFromGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMemberFromGroupItemResponse(rsp)
}

// AddMemberToGroupItemWithResponse request returning *AddMemberToGroupItemResponse
func (c *ClientWithResponses) AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error) {
	rsp, err := c.AddMemberToGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMemberToGroupItemResponse(rsp)
}

// RemoveItemFromRegistryWithResponse request returning *RemoveItemFromRegistryResponse
func (c *ClientWithResponses) RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error) {
	rsp, err := c.RemoveItemFromRegistry(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromRegistryResponse(rsp)
}

// GetItemByNameWithResponse request returning *GetItemByNameResponse
func (c *ClientWithResponses) GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error) {
	rsp, err := c.GetItemByName(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemByNameResponse(rsp)
}

// SendItemCommandWithBodyWithResponse request with arbitrary body returning *SendItemCommandResponse
func (c *ClientWithResponses) SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error) {
	rsp, err := c.SendItemCommandWithBody(ctx, itemname, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendItemCommandResponse(rsp)
}

// AddOrUpdateItemInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistryWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistry(ctx, itemname, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

// RemoveMetadataFromItemWithResponse request returning *RemoveMetadataFromItemResponse
func (c *ClientWithResponses) RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error) {
	rsp, err := c.RemoveMetadataFromItem(ctx, itemname, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMetadataFromItemResponse(rsp)
}

// AddMetadataToItemWithBodyWithResponse request with arbitrary body returning *AddMetadataToItemResponse
func (c *ClientWithResponses) AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItemWithBody(ctx, itemname, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

func (c *ClientWithResponses) AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItem(ctx, itemname, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

// GetItemStateWithResponse request returning *GetItemStateResponse
func (c *ClientWithResponses) GetItemStateWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemStateResponse, error) {
	rsp, err := c.GetItemState(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemStateResponse(rsp)
}

// UpdateItemStateWithBodyWithResponse request with arbitrary body returning *UpdateItemStateResponse
func (c *ClientWithResponses) UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error) {
	rsp, err := c.UpdateItemStateWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemStateResponse(rsp)
}

// RemoveTagFromItemWithResponse request returning *RemoveTagFromItemResponse
func (c *ClientWithResponses) RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error) {
	rsp, err := c.RemoveTagFromItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagFromItemResponse(rsp)
}

// AddTagToItemWithResponse request returning *AddTagToItemResponse
func (c *ClientWithResponses) AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error) {
	rsp, err := c.AddTagToItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTagToItemResponse(rsp)
}

// GetItemLinksWithResponse request returning *GetItemLinksResponse
func (c *ClientWithResponses) GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error) {
	rsp, err := c.GetItemLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinksResponse(rsp)
}

// UnlinkItemFromChannelWithResponse request returning *UnlinkItemFromChannelResponse
func (c *ClientWithResponses) UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error) {
	rsp, err := c.UnlinkItemFromChannel(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkItemFromChannelResponse(rsp)
}

// GetItemLinkWithResponse request returning *GetItemLinkResponse
func (c *ClientWithResponses) GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error) {
	rsp, err := c.GetItemLink(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinkResponse(rsp)
}

// LinkItemToChannelWithBodyWithResponse request with arbitrary body returning *LinkItemToChannelResponse
func (c *ClientWithResponses) LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error) {
	rsp, err := c.LinkItemToChannelWithBody(ctx, itemName, channelUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkItemToChannelResponse(rsp)
}

func (c *ClientWithResponses) LinkItemToChannelWithResponse(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error) {
	rsp, err := c.LinkItemToChannel(ctx, itemName, channelUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkItemToChannelResponse(rsp)
}

// GetModuleTypesWithResponse request returning *GetModuleTypesResponse
func (c *ClientWithResponses) GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error) {
	rsp, err := c.GetModuleTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypesResponse(rsp)
}

// GetModuleTypeByIdWithResponse request returning *GetModuleTypeByIdResponse
func (c *ClientWithResponses) GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error) {
	rsp, err := c.GetModuleTypeById(ctx, moduleTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypeByIdResponse(rsp)
}

// GetPersistenceServicesWithResponse request returning *GetPersistenceServicesResponse
func (c *ClientWithResponses) GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error) {
	rsp, err := c.GetPersistenceServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceServicesResponse(rsp)
}

// GetItemsForPersistenceServiceWithResponse request returning *GetItemsForPersistenceServiceResponse
func (c *ClientWithResponses) GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error) {
	rsp, err := c.GetItemsForPersistenceService(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsForPersistenceServiceResponse(rsp)
}

// DeleteItemFromPersistenceServiceWithResponse request returning *DeleteItemFromPersistenceServiceResponse
func (c *ClientWithResponses) DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error) {
	rsp, err := c.DeleteItemFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemFromPersistenceServiceResponse(rsp)
}

// GetItemDataFromPersistenceServiceWithResponse request returning *GetItemDataFromPersistenceServiceResponse
func (c *ClientWithResponses) GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error) {
	rsp, err := c.GetItemDataFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemDataFromPersistenceServiceResponse(rsp)
}

// StoreItemDataInPersistenceServiceWithResponse request returning *StoreItemDataInPersistenceServiceResponse
func (c *ClientWithResponses) StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error) {
	rsp, err := c.StoreItemDataInPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreItemDataInPersistenceServiceResponse(rsp)
}

// GetProfileTypesWithResponse request returning *GetProfileTypesResponse
func (c *ClientWithResponses) GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error) {
	rsp, err := c.GetProfileTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileTypesResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// GetScheduleRuleSimulationsWithResponse request returning *GetScheduleRuleSimulationsResponse
func (c *ClientWithResponses) GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error) {
	rsp, err := c.GetScheduleRuleSimulations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleRuleSimulationsResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleByIdWithResponse request returning *GetRuleByIdResponse
func (c *ClientWithResponses) GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error) {
	rsp, err := c.GetRuleById(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleByIdResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// GetRuleActionsWithResponse request returning *GetRuleActionsResponse
func (c *ClientWithResponses) GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error) {
	rsp, err := c.GetRuleActions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleActionsResponse(rsp)
}

// GetRuleConditionsWithResponse request returning *GetRuleConditionsResponse
func (c *ClientWithResponses) GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error) {
	rsp, err := c.GetRuleConditions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConditionsResponse(rsp)
}

// GetRuleConfigurationWithResponse request returning *GetRuleConfigurationResponse
func (c *ClientWithResponses) GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error) {
	rsp, err := c.GetRuleConfiguration(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConfigurationResponse(rsp)
}

// UpdateRuleConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateRuleConfigurationResponse
func (c *ClientWithResponses) UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfigurationWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfiguration(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

// EnableRuleWithBodyWithResponse request with arbitrary body returning *EnableRuleResponse
func (c *ClientWithResponses) EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error) {
	rsp, err := c.EnableRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableRuleResponse(rsp)
}

// RunRuleNowWithResponse request returning *RunRuleNowResponse
func (c *ClientWithResponses) RunRuleNowWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*RunRuleNowResponse, error) {
	rsp, err := c.RunRuleNow(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRuleNowResponse(rsp)
}

// GetRuleTriggersWithResponse request returning *GetRuleTriggersResponse
func (c *ClientWithResponses) GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error) {
	rsp, err := c.GetRuleTriggers(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleTriggersResponse(rsp)
}

// GetRuleModuleByIdWithResponse request returning *GetRuleModuleByIdResponse
func (c *ClientWithResponses) GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error) {
	rsp, err := c.GetRuleModuleById(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleByIdResponse(rsp)
}

// GetRuleModuleConfigWithResponse request returning *GetRuleModuleConfigResponse
func (c *ClientWithResponses) GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error) {
	rsp, err := c.GetRuleModuleConfig(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigResponse(rsp)
}

// GetRuleModuleConfigParameterWithResponse request returning *GetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.GetRuleModuleConfigParameter(ctx, ruleUID, moduleCategory, id, param, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigParameterResponse(rsp)
}

// SetRuleModuleConfigParameterWithBodyWithResponse request with arbitrary body returning *SetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.SetRuleModuleConfigParameterWithBody(ctx, ruleUID, moduleCategory, id, param, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRuleModuleConfigParameterResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// GetServicesByIdWithResponse request returning *GetServicesByIdResponse
func (c *ClientWithResponses) GetServicesByIdWithResponse(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error) {
	rsp, err := c.GetServicesById(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesByIdResponse(rsp)
}

// DeleteServiceConfigWithResponse request returning *DeleteServiceConfigResponse
func (c *ClientWithResponses) DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error) {
	rsp, err := c.DeleteServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceConfigResponse(rsp)
}

// GetServiceConfigWithResponse request returning *GetServiceConfigResponse
func (c *ClientWithResponses) GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error) {
	rsp, err := c.GetServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceConfigResponse(rsp)
}

// UpdateServiceConfigWithBodyWithResponse request with arbitrary body returning *UpdateServiceConfigResponse
func (c *ClientWithResponses) UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfigWithBody(ctx, serviceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfig(ctx, serviceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

// GetServiceContextWithResponse request returning *GetServiceContextResponse
func (c *ClientWithResponses) GetServiceContextWithResponse(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error) {
	rsp, err := c.GetServiceContext(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceContextResponse(rsp)
}

// GetSitemapsWithResponse request returning *GetSitemapsResponse
func (c *ClientWithResponses) GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error) {
	rsp, err := c.GetSitemaps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapsResponse(rsp)
}

// CreateSitemapEventSubscriptionWithResponse request returning *CreateSitemapEventSubscriptionResponse
func (c *ClientWithResponses) CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error) {
	rsp, err := c.CreateSitemapEventSubscription(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSitemapEventSubscriptionResponse(rsp)
}

// GetSitemapEventsWithResponse request returning *GetSitemapEventsResponse
func (c *ClientWithResponses) GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error) {
	rsp, err := c.GetSitemapEvents(ctx, subscriptionid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapEventsResponse(rsp)
}

// GetSitemapByNameWithResponse request returning *GetSitemapByNameResponse
func (c *ClientWithResponses) GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error) {
	rsp, err := c.GetSitemapByName(ctx, sitemapname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapByNameResponse(rsp)
}

// PollDataForSitemapWithResponse request returning *PollDataForSitemapResponse
func (c *ClientWithResponses) PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error) {
	rsp, err := c.PollDataForSitemap(ctx, sitemapname, pageid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollDataForSitemapResponse(rsp)
}

// GetSystemInformationWithResponse request returning *GetSystemInformationResponse
func (c *ClientWithResponses) GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error) {
	rsp, err := c.GetSystemInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInformationResponse(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResponse
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error) {
	rsp, err := c.GetTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResponse(rsp)
}

// GetTemplateByIdWithResponse request returning *GetTemplateByIdResponse
func (c *ClientWithResponses) GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error) {
	rsp, err := c.GetTemplateById(ctx, templateUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateByIdResponse(rsp)
}

// GetThingTypesWithResponse request returning *GetThingTypesResponse
func (c *ClientWithResponses) GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error) {
	rsp, err := c.GetThingTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypesResponse(rsp)
}

// GetThingTypeByIdWithResponse request returning *GetThingTypeByIdResponse
func (c *ClientWithResponses) GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error) {
	rsp, err := c.GetThingTypeById(ctx, thingTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypeByIdResponse(rsp)
}

// GetThingsWithResponse request returning *GetThingsResponse
func (c *ClientWithResponses) GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error) {
	rsp, err := c.GetThings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingsResponse(rsp)
}

// CreateThingInRegistryWithBodyWithResponse request with arbitrary body returning *CreateThingInRegistryResponse
func (c *ClientWithResponses) CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

func (c *ClientWithResponses) CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

// RemoveThingByIdWithResponse request returning *RemoveThingByIdResponse
func (c *ClientWithResponses) RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error) {
	rsp, err := c.RemoveThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveThingByIdResponse(rsp)
}

// GetThingByIdWithResponse request returning *GetThingByIdResponse
func (c *ClientWithResponses) GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error) {
	rsp, err := c.GetThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingByIdResponse(rsp)
}

// UpdateThingWithBodyWithResponse request with arbitrary body returning *UpdateThingResponse
func (c *ClientWithResponses) UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThing(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

// UpdateThingConfigWithBodyWithResponse request with arbitrary body returning *UpdateThingConfigResponse
func (c *ClientWithResponses) UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfigWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfig(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

// GetThingConfigStatusWithResponse request returning *GetThingConfigStatusResponse
func (c *ClientWithResponses) GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error) {
	rsp, err := c.GetThingConfigStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingConfigStatusResponse(rsp)
}

// EnableThingWithBodyWithResponse request with arbitrary body returning *EnableThingResponse
func (c *ClientWithResponses) EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error) {
	rsp, err := c.EnableThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableThingResponse(rsp)
}

// GetThingFirmwareStatusWithResponse request returning *GetThingFirmwareStatusResponse
func (c *ClientWithResponses) GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error) {
	rsp, err := c.GetThingFirmwareStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingFirmwareStatusResponse(rsp)
}

// UpdateThingFirmwareWithResponse request returning *UpdateThingFirmwareResponse
func (c *ClientWithResponses) UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error) {
	rsp, err := c.UpdateThingFirmware(ctx, thingUID, firmwareVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingFirmwareResponse(rsp)
}

// GetAvailableFirmwaresForThingWithResponse request returning *GetAvailableFirmwaresForThingResponse
func (c *ClientWithResponses) GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error) {
	rsp, err := c.GetAvailableFirmwaresForThing(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableFirmwaresForThingResponse(rsp)
}

// GetThingStatusWithResponse request returning *GetThingStatusResponse
func (c *ClientWithResponses) GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error) {
	rsp, err := c.GetThingStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingStatusResponse(rsp)
}

// GetRegisteredUIComponentsInNamespaceWithResponse request returning *GetRegisteredUIComponentsInNamespaceResponse
func (c *ClientWithResponses) GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	rsp, err := c.GetRegisteredUIComponentsInNamespace(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegisteredUIComponentsInNamespaceResponse(rsp)
}

// AddUIComponentToNamespaceWithBodyWithResponse request with arbitrary body returning *AddUIComponentToNamespaceResponse
func (c *ClientWithResponses) AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error) {
	rsp, err := c.AddUIComponentToNamespaceWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUIComponentToNamespaceResponse(rsp)
}

func (c *ClientWithResponses) AddUIComponentToNamespaceWithResponse(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error) {
	rsp, err := c.AddUIComponentToNamespace(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUIComponentToNamespaceResponse(rsp)
}

// RemoveUIComponentFromNamespaceWithResponse request returning *RemoveUIComponentFromNamespaceResponse
func (c *ClientWithResponses) RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error) {
	rsp, err := c.RemoveUIComponentFromNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUIComponentFromNamespaceResponse(rsp)
}

// GetUIComponentInNamespaceWithResponse request returning *GetUIComponentInNamespaceResponse
func (c *ClientWithResponses) GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error) {
	rsp, err := c.GetUIComponentInNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUIComponentInNamespaceResponse(rsp)
}

// UpdateUIComponentInNamespaceWithBodyWithResponse request with arbitrary body returning *UpdateUIComponentInNamespaceResponse
func (c *ClientWithResponses) UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error) {
	rsp, err := c.UpdateUIComponentInNamespaceWithBody(ctx, namespace, componentUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUIComponentInNamespaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error) {
	rsp, err := c.UpdateUIComponentInNamespace(ctx, namespace, componentUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUIComponentInNamespaceResponse(rsp)
}

// GetUITilesWithResponse request returning *GetUITilesResponse
func (c *ClientWithResponses) GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error) {
	rsp, err := c.GetUITiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUITilesResponse(rsp)
}

// GetUUIDWithResponse request returning *GetUUIDResponse
func (c *ClientWithResponses) GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error) {
	rsp, err := c.GetUUID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUUIDResponse(rsp)
}

// GetDefaultVoiceWithResponse request returning *GetDefaultVoiceResponse
func (c *ClientWithResponses) GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error) {
	rsp, err := c.GetDefaultVoice(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultVoiceResponse(rsp)
}

// GetVoiceInterpretersWithResponse request returning *GetVoiceInterpretersResponse
func (c *ClientWithResponses) GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error) {
	rsp, err := c.GetVoiceInterpreters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpretersResponse(rsp)
}

// InterpretTextByDefaultInterpreterWithBodyWithResponse request with arbitrary body returning *InterpretTextByDefaultInterpreterResponse
func (c *ClientWithResponses) InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error) {
	rsp, err := c.InterpretTextByDefaultInterpreterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextByDefaultInterpreterResponse(rsp)
}

// GetVoiceInterpreterByUIDWithResponse request returning *GetVoiceInterpreterByUIDResponse
func (c *ClientWithResponses) GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error) {
	rsp, err := c.GetVoiceInterpreterByUID(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpreterByUIDResponse(rsp)
}

// InterpretTextWithBodyWithResponse request with arbitrary body returning *InterpretTextResponse
func (c *ClientWithResponses) InterpretTextWithBodyWithResponse(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error) {
	rsp, err := c.InterpretTextWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextResponse(rsp)
}

// TextToSpeechWithBodyWithResponse request with arbitrary body returning *TextToSpeechResponse
func (c *ClientWithResponses) TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error) {
	rsp, err := c.TextToSpeechWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTextToSpeechResponse(rsp)
}

// GetVoicesWithResponse request returning *GetVoicesResponse
func (c *ClientWithResponses) GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error) {
	rsp, err := c.GetVoices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoicesResponse(rsp)
}

// ParseGetRootResponse parses an HTTP response from a GetRootWithResponse call
func ParseGetRootResponse(rsp *http.Response) (*GetRootResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonsResponse parses an HTTP response from a GetAddonsWithResponse call
func ParseGetAddonsResponse(rsp *http.Response) (*GetAddonsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonTypesResponse parses an HTTP response from a GetAddonTypesWithResponse call
func ParseGetAddonTypesResponse(rsp *http.Response) (*GetAddonTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddonType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonServicesResponse parses an HTTP response from a GetAddonServicesWithResponse call
func ParseGetAddonServicesResponse(rsp *http.Response) (*GetAddonServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddonType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallAddonFromURLResponse parses an HTTP response from a InstallAddonFromURLWithResponse call
func ParseInstallAddonFromURLResponse(rsp *http.Response) (*InstallAddonFromURLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallAddonFromURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAddonByIdResponse parses an HTTP response from a GetAddonByIdWithResponse call
func ParseGetAddonByIdResponse(rsp *http.Response) (*GetAddonByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallAddonByIdResponse parses an HTTP response from a InstallAddonByIdWithResponse call
func ParseInstallAddonByIdResponse(rsp *http.Response) (*InstallAddonByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUninstallAddonResponse parses an HTTP response from a UninstallAddonWithResponse call
func ParseUninstallAddonResponse(rsp *http.Response) (*UninstallAddonResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAudioDefaultSinkResponse parses an HTTP response from a GetAudioDefaultSinkWithResponse call
func ParseGetAudioDefaultSinkResponse(rsp *http.Response) (*GetAudioDefaultSinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioDefaultSourceResponse parses an HTTP response from a GetAudioDefaultSourceWithResponse call
func ParseGetAudioDefaultSourceResponse(rsp *http.Response) (*GetAudioDefaultSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSinksResponse parses an HTTP response from a GetAudioSinksWithResponse call
func ParseGetAudioSinksResponse(rsp *http.Response) (*GetAudioSinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSourcesResponse parses an HTTP response from a GetAudioSourcesWithResponse call
func ParseGetAudioSourcesResponse(rsp *http.Response) (*GetAudioSourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiTokensResponse parses an HTTP response from a GetApiTokensWithResponse call
func ParseGetApiTokensResponse(rsp *http.Response) (*GetApiTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserApiTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveApiTokenResponse parses an HTTP response from a RemoveApiTokenWithResponse call
func ParseRemoveApiTokenResponse(rsp *http.Response) (*RemoveApiTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveApiTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSessionResponse parses an HTTP response from a DeleteSessionWithResponse call
func ParseDeleteSessionResponse(rsp *http.Response) (*DeleteSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSessionsForCurrentUserResponse parses an HTTP response from a GetSessionsForCurrentUserWithResponse call
func ParseGetSessionsForCurrentUserResponse(rsp *http.Response) (*GetSessionsForCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionsForCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserSessionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingsResponse parses an HTTP response from a GetBindingsWithResponse call
func ParseGetBindingsResponse(rsp *http.Response) (*GetBindingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BindingInfoDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingConfigurationResponse parses an HTTP response from a GetBindingConfigurationWithResponse call
func ParseGetBindingConfigurationResponse(rsp *http.Response) (*GetBindingConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBindingConfigurationResponse parses an HTTP response from a UpdateBindingConfigurationWithResponse call
func ParseUpdateBindingConfigurationResponse(rsp *http.Response) (*UpdateBindingConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBindingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypesResponse parses an HTTP response from a GetChannelTypesWithResponse call
func ParseGetChannelTypesResponse(rsp *http.Response) (*GetChannelTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypeByUIDResponse parses an HTTP response from a GetChannelTypeByUIDWithResponse call
func ParseGetChannelTypeByUIDResponse(rsp *http.Response) (*GetChannelTypeByUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypeByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLinkableItemTypesByChannelTypeUIDResponse parses an HTTP response from a GetLinkableItemTypesByChannelTypeUIDWithResponse call
func ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp *http.Response) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkableItemTypesByChannelTypeUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionsResponse parses an HTTP response from a GetConfigDescriptionsWithResponse call
func ParseGetConfigDescriptionsResponse(rsp *http.Response) (*GetConfigDescriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionByURIResponse parses an HTTP response from a GetConfigDescriptionByURIWithResponse call
func ParseGetConfigDescriptionByURIResponse(rsp *http.Response) (*GetConfigDescriptionByURIResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionByURIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingsWithDiscoverySupportResponse parses an HTTP response from a GetBindingsWithDiscoverySupportWithResponse call
func ParseGetBindingsWithDiscoverySupportResponse(rsp *http.Response) (*GetBindingsWithDiscoverySupportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingsWithDiscoverySupportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScanResponse parses an HTTP response from a ScanWithResponse call
func ParseScanResponse(rsp *http.Response) (*ScanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInitNewStateTackerResponse parses an HTTP response from a InitNewStateTackerWithResponse call
func ParseInitNewStateTackerResponse(rsp *http.Response) (*InitNewStateTackerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitNewStateTackerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemListForStateUpdatesResponse parses an HTTP response from a UpdateItemListForStateUpdatesWithResponse call
func ParseUpdateItemListForStateUpdatesResponse(rsp *http.Response) (*UpdateItemListForStateUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemListForStateUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGalleryWidgetListResponse parses an HTTP response from a GetGalleryWidgetListWithResponse call
func ParseGetGalleryWidgetListResponse(rsp *http.Response) (*GetGalleryWidgetListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGalleryWidgetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GalleryWidgetsListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGalleryWidgetsItemResponse parses an HTTP response from a GetGalleryWidgetsItemWithResponse call
func ParseGetGalleryWidgetsItemResponse(rsp *http.Response) (*GetGalleryWidgetsItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGalleryWidgetsItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GalleryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIconSetsResponse parses an HTTP response from a GetIconSetsWithResponse call
func ParseGetIconSetsResponse(rsp *http.Response) (*GetIconSetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIconSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IconSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDiscoveredInboxItemsResponse parses an HTTP response from a GetDiscoveredInboxItemsWithResponse call
func ParseGetDiscoveredInboxItemsResponse(rsp *http.Response) (*GetDiscoveredInboxItemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscoveredInboxItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiscoveryResultDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveItemFromInboxResponse parses an HTTP response from a RemoveItemFromInboxWithResponse call
func ParseRemoveItemFromInboxResponse(rsp *http.Response) (*RemoveItemFromInboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromInboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseApproveInboxItemByIdResponse parses an HTTP response from a ApproveInboxItemByIdWithResponse call
func ParseApproveInboxItemByIdResponse(rsp *http.Response) (*ApproveInboxItemByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveInboxItemByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFlagInboxItemAsIgnoredResponse parses an HTTP response from a FlagInboxItemAsIgnoredWithResponse call
func ParseFlagInboxItemAsIgnoredResponse(rsp *http.Response) (*FlagInboxItemAsIgnoredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FlagInboxItemAsIgnoredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveIgnoreFlagOnInboxItemResponse parses an HTTP response from a RemoveIgnoreFlagOnInboxItemWithResponse call
func ParseRemoveIgnoreFlagOnInboxItemResponse(rsp *http.Response) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveIgnoreFlagOnInboxItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemsResponse parses an HTTP response from a GetItemsWithResponse call
func ParseGetItemsResponse(rsp *http.Response) (*GetItemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrUpdateItemsInRegistryResponse parses an HTTP response from a AddOrUpdateItemsInRegistryWithResponse call
func ParseAddOrUpdateItemsInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemsInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemsInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMemberFromGroupItemResponse parses an HTTP response from a RemoveMemberFromGroupItemWithResponse call
func ParseRemoveMemberFromGroupItemResponse(rsp *http.Response) (*RemoveMemberFromGroupItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMemberFromGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMemberToGroupItemResponse parses an HTTP response from a AddMemberToGroupItemWithResponse call
func ParseAddMemberToGroupItemResponse(rsp *http.Response) (*AddMemberToGroupItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMemberToGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveItemFromRegistryResponse parses an HTTP response from a RemoveItemFromRegistryWithResponse call
func ParseRemoveItemFromRegistryResponse(rsp *http.Response) (*RemoveItemFromRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemByNameResponse parses an HTTP response from a GetItemByNameWithResponse call
func ParseGetItemByNameResponse(rsp *http.Response) (*GetItemByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendItemCommandResponse parses an HTTP response from a SendItemCommandWithResponse call
func ParseSendItemCommandResponse(rsp *http.Response) (*SendItemCommandResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendItemCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOrUpdateItemInRegistryResponse parses an HTTP response from a AddOrUpdateItemInRegistryWithResponse call
func ParseAddOrUpdateItemInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMetadataFromItemResponse parses an HTTP response from a RemoveMetadataFromItemWithResponse call
func ParseRemoveMetadataFromItemResponse(rsp *http.Response) (*RemoveMetadataFromItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMetadataFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMetadataToItemResponse parses an HTTP response from a AddMetadataToItemWithResponse call
func ParseAddMetadataToItemResponse(rsp *http.Response) (*AddMetadataToItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMetadataToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemStateResponse parses an HTTP response from a GetItemStateWithResponse call
func ParseGetItemStateResponse(rsp *http.Response) (*GetItemStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemStateResponse parses an HTTP response from a UpdateItemStateWithResponse call
func ParseUpdateItemStateResponse(rsp *http.Response) (*UpdateItemStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveTagFromItemResponse parses an HTTP response from a RemoveTagFromItemWithResponse call
func ParseRemoveTagFromItemResponse(rsp *http.Response) (*RemoveTagFromItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddTagToItemResponse parses an HTTP response from a AddTagToItemWithResponse call
func ParseAddTagToItemResponse(rsp *http.Response) (*AddTagToItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTagToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinksResponse parses an HTTP response from a GetItemLinksWithResponse call
func ParseGetItemLinksResponse(rsp *http.Response) (*GetItemLinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemChannelLinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkItemFromChannelResponse parses an HTTP response from a UnlinkItemFromChannelWithResponse call
func ParseUnlinkItemFromChannelResponse(rsp *http.Response) (*UnlinkItemFromChannelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkItemFromChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinkResponse parses an HTTP response from a GetItemLinkWithResponse call
func ParseGetItemLinkResponse(rsp *http.Response) (*GetItemLinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedItemChannelLinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkItemToChannelResponse parses an HTTP response from a LinkItemToChannelWithResponse call
func ParseLinkItemToChannelResponse(rsp *http.Response) (*LinkItemToChannelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkItemToChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModuleTypesResponse parses an HTTP response from a GetModuleTypesWithResponse call
func ParseGetModuleTypesResponse(rsp *http.Response) (*GetModuleTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModuleTypeByIdResponse parses an HTTP response from a GetModuleTypeByIdWithResponse call
func ParseGetModuleTypeByIdResponse(rsp *http.Response) (*GetModuleTypeByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersistenceServicesResponse parses an HTTP response from a GetPersistenceServicesWithResponse call
func ParseGetPersistenceServicesResponse(rsp *http.Response) (*GetPersistenceServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemsForPersistenceServiceResponse parses an HTTP response from a GetItemsForPersistenceServiceWithResponse call
func ParseGetItemsForPersistenceServiceResponse(rsp *http.Response) (*GetItemsForPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsForPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceItemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteItemFromPersistenceServiceResponse parses an HTTP response from a DeleteItemFromPersistenceServiceWithResponse call
func ParseDeleteItemFromPersistenceServiceResponse(rsp *http.Response) (*DeleteItemFromPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemDataFromPersistenceServiceResponse parses an HTTP response from a GetItemDataFromPersistenceServiceWithResponse call
func ParseGetItemDataFromPersistenceServiceResponse(rsp *http.Response) (*GetItemDataFromPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemDataFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemHistoryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreItemDataInPersistenceServiceResponse parses an HTTP response from a StoreItemDataInPersistenceServiceWithResponse call
func ParseStoreItemDataInPersistenceServiceResponse(rsp *http.Response) (*StoreItemDataInPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreItemDataInPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProfileTypesResponse parses an HTTP response from a GetProfileTypesWithResponse call
func ParseGetProfileTypesResponse(rsp *http.Response) (*GetProfileTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProfileTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScheduleRuleSimulationsResponse parses an HTTP response from a GetScheduleRuleSimulationsWithResponse call
func ParseGetScheduleRuleSimulationsResponse(rsp *http.Response) (*GetScheduleRuleSimulationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleRuleSimulationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RuleExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleByIdResponse parses an HTTP response from a GetRuleByIdWithResponse call
func ParseGetRuleByIdResponse(rsp *http.Response) (*GetRuleByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleActionsResponse parses an HTTP response from a GetRuleActionsWithResponse call
func ParseGetRuleActionsResponse(rsp *http.Response) (*GetRuleActionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConditionsResponse parses an HTTP response from a GetRuleConditionsWithResponse call
func ParseGetRuleConditionsResponse(rsp *http.Response) (*GetRuleConditionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConditionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConfigurationResponse parses an HTTP response from a GetRuleConfigurationWithResponse call
func ParseGetRuleConfigurationResponse(rsp *http.Response) (*GetRuleConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleConfigurationResponse parses an HTTP response from a UpdateRuleConfigurationWithResponse call
func ParseUpdateRuleConfigurationResponse(rsp *http.Response) (*UpdateRuleConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnableRuleResponse parses an HTTP response from a EnableRuleWithResponse call
func ParseEnableRuleResponse(rsp *http.Response) (*EnableRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunRuleNowResponse parses an HTTP response from a RunRuleNowWithResponse call
func ParseRunRuleNowResponse(rsp *http.Response) (*RunRuleNowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunRuleNowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleTriggersResponse parses an HTTP response from a GetRuleTriggersWithResponse call
func ParseGetRuleTriggersResponse(rsp *http.Response) (*GetRuleTriggersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TriggerDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleByIdResponse parses an HTTP response from a GetRuleModuleByIdWithResponse call
func ParseGetRuleModuleByIdResponse(rsp *http.Response) (*GetRuleModuleByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigResponse parses an HTTP response from a GetRuleModuleConfigWithResponse call
func ParseGetRuleModuleConfigResponse(rsp *http.Response) (*GetRuleModuleConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigParameterResponse parses an HTTP response from a GetRuleModuleConfigParameterWithResponse call
func ParseGetRuleModuleConfigParameterResponse(rsp *http.Response) (*GetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRuleModuleConfigParameterResponse parses an HTTP response from a SetRuleModuleConfigParameterWithResponse call
func ParseSetRuleModuleConfigParameterResponse(rsp *http.Response) (*SetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesByIdResponse parses an HTTP response from a GetServicesByIdWithResponse call
func ParseGetServicesByIdResponse(rsp *http.Response) (*GetServicesByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceConfigResponse parses an HTTP response from a DeleteServiceConfigWithResponse call
func ParseDeleteServiceConfigResponse(rsp *http.Response) (*DeleteServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceConfigResponse parses an HTTP response from a GetServiceConfigWithResponse call
func ParseGetServiceConfigResponse(rsp *http.Response) (*GetServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceConfigResponse parses an HTTP response from a UpdateServiceConfigWithResponse call
func ParseUpdateServiceConfigResponse(rsp *http.Response) (*UpdateServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceContextResponse parses an HTTP response from a GetServiceContextWithResponse call
func ParseGetServiceContextResponse(rsp *http.Response) (*GetServiceContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSitemapsResponse parses an HTTP response from a GetSitemapsWithResponse call
func ParseGetSitemapsResponse(rsp *http.Response) (*GetSitemapsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSitemapEventSubscriptionResponse parses an HTTP response from a CreateSitemapEventSubscriptionWithResponse call
func ParseCreateSitemapEventSubscriptionResponse(rsp *http.Response) (*CreateSitemapEventSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSitemapEventSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapEventsResponse parses an HTTP response from a GetSitemapEventsWithResponse call
func ParseGetSitemapEventsResponse(rsp *http.Response) (*GetSitemapEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapByNameResponse parses an HTTP response from a GetSitemapByNameWithResponse call
func ParseGetSitemapByNameResponse(rsp *http.Response) (*GetSitemapByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePollDataForSitemapResponse parses an HTTP response from a PollDataForSitemapWithResponse call
func ParsePollDataForSitemapResponse(rsp *http.Response) (*PollDataForSitemapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollDataForSitemapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSystemInformationResponse parses an HTTP response from a GetSystemInformationWithResponse call
func ParseGetSystemInformationResponse(rsp *http.Response) (*GetSystemInformationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfoBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplatesResponse parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResponse(rsp *http.Response) (*GetTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateByIdResponse parses an HTTP response from a GetTemplateByIdWithResponse call
func ParseGetTemplateByIdResponse(rsp *http.Response) (*GetTemplateByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypesResponse parses an HTTP response from a GetThingTypesWithResponse call
func ParseGetThingTypesResponse(rsp *http.Response) (*GetThingTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StrippedThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypeByIdResponse parses an HTTP response from a GetThingTypeByIdWithResponse call
func ParseGetThingTypeByIdResponse(rsp *http.Response) (*GetThingTypeByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingsResponse parses an HTTP response from a GetThingsWithResponse call
func ParseGetThingsResponse(rsp *http.Response) (*GetThingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateThingInRegistryResponse parses an HTTP response from a CreateThingInRegistryWithResponse call
func ParseCreateThingInRegistryResponse(rsp *http.Response) (*CreateThingInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateThingInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveThingByIdResponse parses an HTTP response from a RemoveThingByIdWithResponse call
func ParseRemoveThingByIdResponse(rsp *http.Response) (*RemoveThingByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingByIdResponse parses an HTTP response from a GetThingByIdWithResponse call
func ParseGetThingByIdResponse(rsp *http.Response) (*GetThingByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateThingResponse parses an HTTP response from a UpdateThingWithResponse call
func ParseUpdateThingResponse(rsp *http.Response) (*UpdateThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingConfigResponse parses an HTTP response from a UpdateThingConfigWithResponse call
func ParseUpdateThingConfigResponse(rsp *http.Response) (*UpdateThingConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingConfigStatusResponse parses an HTTP response from a GetThingConfigStatusWithResponse call
func ParseGetThingConfigStatusResponse(rsp *http.Response) (*GetThingConfigStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingConfigStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigStatusMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnableThingResponse parses an HTTP response from a EnableThingWithResponse call
func ParseEnableThingResponse(rsp *http.Response) (*EnableThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingFirmwareStatusResponse parses an HTTP response from a GetThingFirmwareStatusWithResponse call
func ParseGetThingFirmwareStatusResponse(rsp *http.Response) (*GetThingFirmwareStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingFirmwareStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingFirmwareResponse parses an HTTP response from a UpdateThingFirmwareWithResponse call
func ParseUpdateThingFirmwareResponse(rsp *http.Response) (*UpdateThingFirmwareResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingFirmwareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAvailableFirmwaresForThingResponse parses an HTTP response from a GetAvailableFirmwaresForThingWithResponse call
func ParseGetAvailableFirmwaresForThingResponse(rsp *http.Response) (*GetAvailableFirmwaresForThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableFirmwaresForThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FirmwareDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingStatusResponse parses an HTTP response from a GetThingStatusWithResponse call
func ParseGetThingStatusResponse(rsp *http.Response) (*GetThingStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingStatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegisteredUIComponentsInNamespaceResponse parses an HTTP response from a GetRegisteredUIComponentsInNamespaceWithResponse call
func ParseGetRegisteredUIComponentsInNamespaceResponse(rsp *http.Response) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegisteredUIComponentsInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUIComponentToNamespaceResponse parses an HTTP response from a AddUIComponentToNamespaceWithResponse call
func ParseAddUIComponentToNamespaceResponse(rsp *http.Response) (*AddUIComponentToNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUIComponentToNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUIComponentFromNamespaceResponse parses an HTTP response from a RemoveUIComponentFromNamespaceWithResponse call
func ParseRemoveUIComponentFromNamespaceResponse(rsp *http.Response) (*RemoveUIComponentFromNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUIComponentFromNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUIComponentInNamespaceResponse parses an HTTP response from a GetUIComponentInNamespaceWithResponse call
func ParseGetUIComponentInNamespaceResponse(rsp *http.Response) (*GetUIComponentInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUIComponentInNamespaceResponse parses an HTTP response from a UpdateUIComponentInNamespaceWithResponse call
func ParseUpdateUIComponentInNamespaceResponse(rsp *http.Response) (*UpdateUIComponentInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUITilesResponse parses an HTTP response from a GetUITilesWithResponse call
func ParseGetUITilesResponse(rsp *http.Response) (*GetUITilesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUITilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TileDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUUIDResponse parses an HTTP response from a GetUUIDWithResponse call
func ParseGetUUIDResponse(rsp *http.Response) (*GetUUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultVoiceResponse parses an HTTP response from a GetDefaultVoiceWithResponse call
func ParseGetDefaultVoiceResponse(rsp *http.Response) (*GetDefaultVoiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultVoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVoiceInterpretersResponse parses an HTTP response from a GetVoiceInterpretersWithResponse call
func ParseGetVoiceInterpretersResponse(rsp *http.Response) (*GetVoiceInterpretersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpretersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInterpretTextByDefaultInterpreterResponse parses an HTTP response from a InterpretTextByDefaultInterpreterWithResponse call
func ParseInterpretTextByDefaultInterpreterResponse(rsp *http.Response) (*InterpretTextByDefaultInterpreterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextByDefaultInterpreterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoiceInterpreterByUIDResponse parses an HTTP response from a GetVoiceInterpreterByUIDWithResponse call
func ParseGetVoiceInterpreterByUIDResponse(rsp *http.Response) (*GetVoiceInterpreterByUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpreterByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInterpretTextResponse parses an HTTP response from a InterpretTextWithResponse call
func ParseInterpretTextResponse(rsp *http.Response) (*InterpretTextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTextToSpeechResponse parses an HTTP response from a TextToSpeechWithResponse call
func ParseTextToSpeechResponse(rsp *http.Response) (*TextToSpeechResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TextToSpeechResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoicesResponse parses an HTTP response from a GetVoicesWithResponse call
func ParseGetVoicesResponse(rsp *http.Response) (*GetVoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets information about the runtime, the API version and links to resources.
	// (GET /)
	GetRoot(ctx echo.Context) error
	// Get all add-ons.
	// (GET /addons)
	GetAddons(ctx echo.Context, params GetAddonsParams) error
	// Get all add-on types.
	// (GET /addons/services)
	GetAddonTypes(ctx echo.Context, params GetAddonTypesParams) error
	// Get add-on services.
	// (GET /addons/types)
	GetAddonServices(ctx echo.Context, params GetAddonServicesParams) error
	// Installs the add-on from the given URL.
	// (POST /addons/url/{url}/install)
	InstallAddonFromURL(ctx echo.Context, url string) error
	// Get add-on with given ID.
	// (GET /addons/{addonId})
	GetAddonById(ctx echo.Context, addonId string, params GetAddonByIdParams) error
	// Installs the add-on with the given ID.
	// (POST /addons/{addonId}/install)
	InstallAddonById(ctx echo.Context, addonId string, params InstallAddonByIdParams) error
	// Uninstalls the add-on with the given ID.
	// (POST /addons/{addonId}/uninstall)
	UninstallAddon(ctx echo.Context, addonId string, params UninstallAddonParams) error
	// Get the default sink if defined or the first available sink.
	// (GET /audio/defaultsink)
	GetAudioDefaultSink(ctx echo.Context, params GetAudioDefaultSinkParams) error
	// Get the default source if defined or the first available source.
	// (GET /audio/defaultsource)
	GetAudioDefaultSource(ctx echo.Context, params GetAudioDefaultSourceParams) error
	// Get the list of all sinks.
	// (GET /audio/sinks)
	GetAudioSinks(ctx echo.Context, params GetAudioSinksParams) error
	// Get the list of all sources.
	// (GET /audio/sources)
	GetAudioSources(ctx echo.Context, params GetAudioSourcesParams) error
	// List the API tokens associated to the authenticated user.
	// (GET /auth/apitokens)
	GetApiTokens(ctx echo.Context) error
	// Revoke a specified API token associated to the authenticated user.
	// (DELETE /auth/apitokens/{name})
	RemoveApiToken(ctx echo.Context, name string) error
	// Delete the session associated with a refresh token.
	// (POST /auth/logout)
	DeleteSession(ctx echo.Context) error
	// List the sessions associated to the authenticated user.
	// (GET /auth/sessions)
	GetSessionsForCurrentUser(ctx echo.Context) error
	// Get access and refresh tokens.
	// (POST /auth/token)
	GetOAuthToken(ctx echo.Context, params GetOAuthTokenParams) error
	// Get all bindings.
	// (GET /bindings)
	GetBindings(ctx echo.Context, params GetBindingsParams) error
	// Get binding configuration for given binding ID.
	// (GET /bindings/{bindingId}/config)
	GetBindingConfiguration(ctx echo.Context, bindingId string) error
	// Updates a binding configuration for given binding ID and returns the old configuration.
	// (PUT /bindings/{bindingId}/config)
	UpdateBindingConfiguration(ctx echo.Context, bindingId string) error
	// Gets all available channel types.
	// (GET /channel-types)
	GetChannelTypes(ctx echo.Context, params GetChannelTypesParams) error
	// Gets channel type by UID.
	// (GET /channel-types/{channelTypeUID})
	GetChannelTypeByUID(ctx echo.Context, channelTypeUID string, params GetChannelTypeByUIDParams) error
	// Gets the item types the given trigger channel type UID can be linked to.
	// (GET /channel-types/{channelTypeUID}/linkableItemTypes)
	GetLinkableItemTypesByChannelTypeUID(ctx echo.Context, channelTypeUID string) error
	// Gets all available config descriptions.
	// (GET /config-descriptions)
	GetConfigDescriptions(ctx echo.Context, params GetConfigDescriptionsParams) error
	// Gets a config description by URI.
	// (GET /config-descriptions/{uri})
	GetConfigDescriptionByURI(ctx echo.Context, uri string, params GetConfigDescriptionByURIParams) error
	// Gets all bindings that support discovery.
	// (GET /discovery)
	GetBindingsWithDiscoverySupport(ctx echo.Context) error
	// Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
	// (POST /discovery/bindings/{bindingId}/scan)
	Scan(ctx echo.Context, bindingId string) error
	// Get all events.
	// (GET /events)
	GetEvents(ctx echo.Context, params GetEventsParams) error
	// Initiates a new item state tracker connection
	// (GET /events/states)
	InitNewStateTacker(ctx echo.Context) error
	// Changes the list of items a SSE connection will receive state updates to.
	// (POST /events/states/{connectionId})
	UpdateItemListForStateUpdates(ctx echo.Context, connectionId string) error
	// Gets the list of widget gallery items.
	// (GET /habpanel/gallery/{galleryName}/widgets)
	GetGalleryWidgetList(ctx echo.Context, galleryName string) error
	// Gets the details about a widget gallery item.
	// (GET /habpanel/gallery/{galleryName}/widgets/{id})
	GetGalleryWidgetsItem(ctx echo.Context, galleryName string, id string) error
	// Gets all icon sets.
	// (GET /iconsets)
	GetIconSets(ctx echo.Context, params GetIconSetsParams) error
	// Get all discovered things.
	// (GET /inbox)
	GetDiscoveredInboxItems(ctx echo.Context) error
	// Removes the discovery result from the inbox.
	// (DELETE /inbox/{thingUID})
	RemoveItemFromInbox(ctx echo.Context, thingUID string) error
	// Approves the discovery result by adding the thing to the registry.
	// (POST /inbox/{thingUID}/approve)
	ApproveInboxItemById(ctx echo.Context, thingUID string, params ApproveInboxItemByIdParams) error
	// Flags a discovery result as ignored for further processing.
	// (POST /inbox/{thingUID}/ignore)
	FlagInboxItemAsIgnored(ctx echo.Context, thingUID string) error
	// Removes ignore flag from a discovery result.
	// (POST /inbox/{thingUID}/unignore)
	RemoveIgnoreFlagOnInboxItem(ctx echo.Context, thingUID string) error
	// Get all available items.
	// (GET /items)
	GetItems(ctx echo.Context, params GetItemsParams) error
	// Adds a list of items to the registry or updates the existing items.
	// (PUT /items)
	AddOrUpdateItemsInRegistry(ctx echo.Context) error
	// Removes an existing member from a group item.
	// (DELETE /items/{itemName}/members/{memberItemName})
	RemoveMemberFromGroupItem(ctx echo.Context, itemName string, memberItemName string) error
	// Adds a new member to a group item.
	// (PUT /items/{itemName}/members/{memberItemName})
	AddMemberToGroupItem(ctx echo.Context, itemName string, memberItemName string) error
	// Removes an item from the registry.
	// (DELETE /items/{itemname})
	RemoveItemFromRegistry(ctx echo.Context, itemname string) error
	// Gets a single item.
	// (GET /items/{itemname})
	GetItemByName(ctx echo.Context, itemname string, params GetItemByNameParams) error
	// Sends a command to an item.
	// (POST /items/{itemname})
	SendItemCommand(ctx echo.Context, itemname string) error
	// Adds a new item to the registry or updates the existing item.
	// (PUT /items/{itemname})
	AddOrUpdateItemInRegistry(ctx echo.Context, itemname string, params AddOrUpdateItemInRegistryParams) error
	// Removes metadata from an item.
	// (DELETE /items/{itemname}/metadata/{namespace})
	RemoveMetadataFromItem(ctx echo.Context, itemname string, namespace string) error
	// Adds metadata to an item.
	// (PUT /items/{itemname}/metadata/{namespace})
	AddMetadataToItem(ctx echo.Context, itemname string, namespace string) error
	// Gets the state of an item.
	// (GET /items/{itemname}/state)
	GetItemState(ctx echo.Context, itemname string) error
	// Updates the state of an item.
	// (PUT /items/{itemname}/state)
	UpdateItemState(ctx echo.Context, itemname string, params UpdateItemStateParams) error
	// Removes a tag from an item.
	// (DELETE /items/{itemname}/tags/{tag})
	RemoveTagFromItem(ctx echo.Context, itemname string, tag string) error
	// Adds a tag to an item.
	// (PUT /items/{itemname}/tags/{tag})
	AddTagToItem(ctx echo.Context, itemname string, tag string) error
	// Gets all available links.
	// (GET /links)
	GetItemLinks(ctx echo.Context, params GetItemLinksParams) error
	// Unlinks an item from a channel.
	// (DELETE /links/{itemName}/{channelUID})
	UnlinkItemFromChannel(ctx echo.Context, itemName string, channelUID string) error
	// Retrieves an individual link.
	// (GET /links/{itemName}/{channelUID})
	GetItemLink(ctx echo.Context, itemName string, channelUID string) error
	// Links an item to a channel.
	// (PUT /links/{itemName}/{channelUID})
	LinkItemToChannel(ctx echo.Context, itemName string, channelUID string) error
	// Get all available module types.
	// (GET /module-types)
	GetModuleTypes(ctx echo.Context, params GetModuleTypesParams) error
	// Gets a module type corresponding to the given UID.
	// (GET /module-types/{moduleTypeUID})
	GetModuleTypeById(ctx echo.Context, moduleTypeUID string, params GetModuleTypeByIdParams) error
	// Gets a list of persistence services.
	// (GET /persistence)
	GetPersistenceServices(ctx echo.Context, params GetPersistenceServicesParams) error
	// Gets a list of items available via a specific persistence service.
	// (GET /persistence/items)
	GetItemsForPersistenceService(ctx echo.Context, params GetItemsForPersistenceServiceParams) error
	// Delete item data from a specific persistence service.
	// (DELETE /persistence/items/{itemname})
	DeleteItemFromPersistenceService(ctx echo.Context, itemname string, params DeleteItemFromPersistenceServiceParams) error
	// Gets item persistence data from the persistence service.
	// (GET /persistence/items/{itemname})
	GetItemDataFromPersistenceService(ctx echo.Context, itemname string, params GetItemDataFromPersistenceServiceParams) error
	// Stores item persistence data into the persistence service.
	// (PUT /persistence/items/{itemname})
	StoreItemDataInPersistenceService(ctx echo.Context, itemname string, params StoreItemDataInPersistenceServiceParams) error
	// Gets all available profile types.
	// (GET /profile-types)
	GetProfileTypes(ctx echo.Context, params GetProfileTypesParams) error
	// Get available rules, optionally filtered by tags and/or prefix.
	// (GET /rules)
	GetRules(ctx echo.Context, params GetRulesParams) error
	// Creates a rule.
	// (POST /rules)
	CreateRule(ctx echo.Context) error
	// Simulates the executions of rules filtered by tag 'Schedule' within the given times.
	// (GET /rules/schedule/simulations)
	GetScheduleRuleSimulations(ctx echo.Context, params GetScheduleRuleSimulationsParams) error
	// Removes an existing rule corresponding to the given UID.
	// (DELETE /rules/{ruleUID})
	DeleteRule(ctx echo.Context, ruleUID string) error
	// Gets the rule corresponding to the given UID.
	// (GET /rules/{ruleUID})
	GetRuleById(ctx echo.Context, ruleUID string) error
	// Updates an existing rule corresponding to the given UID.
	// (PUT /rules/{ruleUID})
	UpdateRule(ctx echo.Context, ruleUID string) error
	// Gets the rule actions.
	// (GET /rules/{ruleUID}/actions)
	GetRuleActions(ctx echo.Context, ruleUID string) error
	// Gets the rule conditions.
	// (GET /rules/{ruleUID}/conditions)
	GetRuleConditions(ctx echo.Context, ruleUID string) error
	// Gets the rule configuration values.
	// (GET /rules/{ruleUID}/config)
	GetRuleConfiguration(ctx echo.Context, ruleUID string) error
	// Sets the rule configuration values.
	// (PUT /rules/{ruleUID}/config)
	UpdateRuleConfiguration(ctx echo.Context, ruleUID string) error
	// Sets the rule enabled status.
	// (POST /rules/{ruleUID}/enable)
	EnableRule(ctx echo.Context, ruleUID string) error
	// Executes actions of the rule.
	// (POST /rules/{ruleUID}/runnow)
	RunRuleNow(ctx echo.Context, ruleUID string) error
	// Gets the rule triggers.
	// (GET /rules/{ruleUID}/triggers)
	GetRuleTriggers(ctx echo.Context, ruleUID string) error
	// Gets the rule's module corresponding to the given Category and ID.
	// (GET /rules/{ruleUID}/{moduleCategory}/{id})
	GetRuleModuleById(ctx echo.Context, ruleUID string, moduleCategory string, id string) error
	// Gets the module's configuration.
	// (GET /rules/{ruleUID}/{moduleCategory}/{id}/config)
	GetRuleModuleConfig(ctx echo.Context, ruleUID string, moduleCategory string, id string) error
	// Gets the module's configuration parameter.
	// (GET /rules/{ruleUID}/{moduleCategory}/{id}/config/{param})
	GetRuleModuleConfigParameter(ctx echo.Context, ruleUID string, moduleCategory string, id string, param string) error
	// Sets the module's configuration parameter value.
	// (PUT /rules/{ruleUID}/{moduleCategory}/{id}/config/{param})
	SetRuleModuleConfigParameter(ctx echo.Context, ruleUID string, moduleCategory string, id string, param string) error
	// Get all configurable services.
	// (GET /services)
	GetServices(ctx echo.Context, params GetServicesParams) error
	// Get configurable service for given service ID.
	// (GET /services/{serviceId})
	GetServicesById(ctx echo.Context, serviceId string, params GetServicesByIdParams) error
	// Deletes a service configuration for given service ID and returns the old configuration.
	// (DELETE /services/{serviceId}/config)
	DeleteServiceConfig(ctx echo.Context, serviceId string) error
	// Get service configuration for given service ID.
	// (GET /services/{serviceId}/config)
	GetServiceConfig(ctx echo.Context, serviceId string) error
	// Updates a service configuration for given service ID and returns the old configuration.
	// (PUT /services/{serviceId}/config)
	UpdateServiceConfig(ctx echo.Context, serviceId string, params UpdateServiceConfigParams) error
	// Get existing multiple context service configurations for the given factory PID.
	// (GET /services/{serviceId}/contexts)
	GetServiceContext(ctx echo.Context, serviceId string, params GetServiceContextParams) error
	// Get all available sitemaps.
	// (GET /sitemaps)
	GetSitemaps(ctx echo.Context) error
	// Creates a sitemap event subscription.
	// (POST /sitemaps/events/subscribe)
	CreateSitemapEventSubscription(ctx echo.Context) error
	// Get sitemap events.
	// (GET /sitemaps/events/{subscriptionid})
	GetSitemapEvents(ctx echo.Context, subscriptionid string, params GetSitemapEventsParams) error
	// Get sitemap by name.
	// (GET /sitemaps/{sitemapname})
	GetSitemapByName(ctx echo.Context, sitemapname string, params GetSitemapByNameParams) error
	// Polls the data for a sitemap.
	// (GET /sitemaps/{sitemapname}/{pageid})
	PollDataForSitemap(ctx echo.Context, sitemapname string, pageid string, params PollDataForSitemapParams) error
	// Gets information about the system.
	// (GET /systeminfo)
	GetSystemInformation(ctx echo.Context) error
	// Get all available templates.
	// (GET /templates)
	GetTemplates(ctx echo.Context, params GetTemplatesParams) error
	// Gets a template corresponding to the given UID.
	// (GET /templates/{templateUID})
	GetTemplateById(ctx echo.Context, templateUID string, params GetTemplateByIdParams) error
	// Gets all available thing types without config description, channels and properties.
	// (GET /thing-types)
	GetThingTypes(ctx echo.Context, params GetThingTypesParams) error
	// Gets thing type by UID.
	// (GET /thing-types/{thingTypeUID})
	GetThingTypeById(ctx echo.Context, thingTypeUID string, params GetThingTypeByIdParams) error
	// Get all available things.
	// (GET /things)
	GetThings(ctx echo.Context, params GetThingsParams) error
	// Creates a new thing and adds it to the registry.
	// (POST /things)
	CreateThingInRegistry(ctx echo.Context, params CreateThingInRegistryParams) error
	// Removes a thing from the registry. Set 'force' to __true__ if you want the thing to be removed immediately.
	// (DELETE /things/{thingUID})
	RemoveThingById(ctx echo.Context, thingUID string, params RemoveThingByIdParams) error
	// Gets thing by UID.
	// (GET /things/{thingUID})
	GetThingById(ctx echo.Context, thingUID string, params GetThingByIdParams) error
	// Updates a thing.
	// (PUT /things/{thingUID})
	UpdateThing(ctx echo.Context, thingUID string, params UpdateThingParams) error
	// Updates thing's configuration.
	// (PUT /things/{thingUID}/config)
	UpdateThingConfig(ctx echo.Context, thingUID string, params UpdateThingConfigParams) error
	// Gets thing config status.
	// (GET /things/{thingUID}/config/status)
	GetThingConfigStatus(ctx echo.Context, thingUID string, params GetThingConfigStatusParams) error
	// Sets the thing enabled status.
	// (PUT /things/{thingUID}/enable)
	EnableThing(ctx echo.Context, thingUID string, params EnableThingParams) error
	// Gets thing's firmware status.
	// (GET /things/{thingUID}/firmware/status)
	GetThingFirmwareStatus(ctx echo.Context, thingUID string, params GetThingFirmwareStatusParams) error
	// Update thing firmware.
	// (PUT /things/{thingUID}/firmware/{firmwareVersion})
	UpdateThingFirmware(ctx echo.Context, thingUID string, firmwareVersion string, params UpdateThingFirmwareParams) error
	// Get all available firmwares for provided thing UID
	// (GET /things/{thingUID}/firmwares)
	GetAvailableFirmwaresForThing(ctx echo.Context, thingUID string, params GetAvailableFirmwaresForThingParams) error
	// Gets thing status.
	// (GET /things/{thingUID}/status)
	GetThingStatus(ctx echo.Context, thingUID string, params GetThingStatusParams) error
	// Get all registered UI components in the specified namespace.
	// (GET /ui/components/{namespace})
	GetRegisteredUIComponentsInNamespace(ctx echo.Context, namespace string, params GetRegisteredUIComponentsInNamespaceParams) error
	// Add an UI component in the specified namespace.
	// (POST /ui/components/{namespace})
	AddUIComponentToNamespace(ctx echo.Context, namespace string) error
	// Remove a specific UI component in the specified namespace.
	// (DELETE /ui/components/{namespace}/{componentUID})
	RemoveUIComponentFromNamespace(ctx echo.Context, namespace string, componentUID string) error
	// Get a specific UI component in the specified namespace.
	// (GET /ui/components/{namespace}/{componentUID})
	GetUIComponentInNamespace(ctx echo.Context, namespace string, componentUID string) error
	// Update a specific UI component in the specified namespace.
	// (PUT /ui/components/{namespace}/{componentUID})
	UpdateUIComponentInNamespace(ctx echo.Context, namespace string, componentUID string) error
	// Get all registered UI tiles.
	// (GET /ui/tiles)
	GetUITiles(ctx echo.Context) error
	// A unified unique id.
	// (GET /uuid)
	GetUUID(ctx echo.Context) error
	// Gets the default voice.
	// (GET /voice/defaultvoice)
	GetDefaultVoice(ctx echo.Context) error
	// Get the list of all interpreters.
	// (GET /voice/interpreters)
	GetVoiceInterpreters(ctx echo.Context, params GetVoiceInterpretersParams) error
	// Sends a text to the default human language interpreter.
	// (POST /voice/interpreters)
	InterpretTextByDefaultInterpreter(ctx echo.Context, params InterpretTextByDefaultInterpreterParams) error
	// Gets a single interpreter.
	// (GET /voice/interpreters/{id})
	GetVoiceInterpreterByUID(ctx echo.Context, id string, params GetVoiceInterpreterByUIDParams) error
	// Sends a text to a given human language interpreter.
	// (POST /voice/interpreters/{id})
	InterpretText(ctx echo.Context, id string, params InterpretTextParams) error
	// Speaks a given text with a given voice through the given audio sink.
	// (POST /voice/say)
	TextToSpeech(ctx echo.Context, params TextToSpeechParams) error
	// Get the list of all voices.
	// (GET /voice/voices)
	GetVoices(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRoot converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRoot(ctx)
	return err
}

// GetAddons converts echo context to params.
func (w *ServerInterfaceWrapper) GetAddons(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAddonsParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAddons(ctx, params)
	return err
}

// GetAddonTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetAddonTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAddonTypesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAddonTypes(ctx, params)
	return err
}

// GetAddonServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetAddonServices(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAddonServicesParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAddonServices(ctx, params)
	return err
}

// InstallAddonFromURL converts echo context to params.
func (w *ServerInterfaceWrapper) InstallAddonFromURL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "url" -------------
	var url string

	err = runtime.BindStyledParameterWithLocation("simple", false, "url", runtime.ParamLocationPath, ctx.Param("url"), &url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InstallAddonFromURL(ctx, url)
	return err
}

// GetAddonById converts echo context to params.
func (w *ServerInterfaceWrapper) GetAddonById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addonId" -------------
	var addonId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "addonId", runtime.ParamLocationPath, ctx.Param("addonId"), &addonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addonId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAddonByIdParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAddonById(ctx, addonId, params)
	return err
}

// InstallAddonById converts echo context to params.
func (w *ServerInterfaceWrapper) InstallAddonById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addonId" -------------
	var addonId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "addonId", runtime.ParamLocationPath, ctx.Param("addonId"), &addonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addonId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstallAddonByIdParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InstallAddonById(ctx, addonId, params)
	return err
}

// UninstallAddon converts echo context to params.
func (w *ServerInterfaceWrapper) UninstallAddon(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addonId" -------------
	var addonId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "addonId", runtime.ParamLocationPath, ctx.Param("addonId"), &addonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addonId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UninstallAddonParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UninstallAddon(ctx, addonId, params)
	return err
}

// GetAudioDefaultSink converts echo context to params.
func (w *ServerInterfaceWrapper) GetAudioDefaultSink(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAudioDefaultSinkParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAudioDefaultSink(ctx, params)
	return err
}

// GetAudioDefaultSource converts echo context to params.
func (w *ServerInterfaceWrapper) GetAudioDefaultSource(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAudioDefaultSourceParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAudioDefaultSource(ctx, params)
	return err
}

// GetAudioSinks converts echo context to params.
func (w *ServerInterfaceWrapper) GetAudioSinks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAudioSinksParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAudioSinks(ctx, params)
	return err
}

// GetAudioSources converts echo context to params.
func (w *ServerInterfaceWrapper) GetAudioSources(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAudioSourcesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAudioSources(ctx, params)
	return err
}

// GetApiTokens converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiTokens(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiTokens(ctx)
	return err
}

// RemoveApiToken converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveApiToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveApiToken(ctx, name)
	return err
}

// DeleteSession converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSession(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteSession(ctx)
	return err
}

// GetSessionsForCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetSessionsForCurrentUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSessionsForCurrentUser(ctx)
	return err
}

// GetOAuthToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetOAuthToken(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOAuthTokenParams
	// ------------- Optional query parameter "useCookie" -------------

	err = runtime.BindQueryParameter("form", true, false, "useCookie", ctx.QueryParams(), &params.UseCookie)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter useCookie: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOAuthToken(ctx, params)
	return err
}

// GetBindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetBindings(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBindingsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBindings(ctx, params)
	return err
}

// GetBindingConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) GetBindingConfiguration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bindingId" -------------
	var bindingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, ctx.Param("bindingId"), &bindingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bindingId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBindingConfiguration(ctx, bindingId)
	return err
}

// UpdateBindingConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBindingConfiguration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bindingId" -------------
	var bindingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, ctx.Param("bindingId"), &bindingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bindingId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateBindingConfiguration(ctx, bindingId)
	return err
}

// GetChannelTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelTypesParams
	// ------------- Optional query parameter "prefixes" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefixes", ctx.QueryParams(), &params.Prefixes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefixes: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelTypes(ctx, params)
	return err
}

// GetChannelTypeByUID converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelTypeByUID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelTypeUID" -------------
	var channelTypeUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, ctx.Param("channelTypeUID"), &channelTypeUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelTypeUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelTypeByUIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelTypeByUID(ctx, channelTypeUID, params)
	return err
}

// GetLinkableItemTypesByChannelTypeUID converts echo context to params.
func (w *ServerInterfaceWrapper) GetLinkableItemTypesByChannelTypeUID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelTypeUID" -------------
	var channelTypeUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, ctx.Param("channelTypeUID"), &channelTypeUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelTypeUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLinkableItemTypesByChannelTypeUID(ctx, channelTypeUID)
	return err
}

// GetConfigDescriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfigDescriptions(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConfigDescriptionsParams
	// ------------- Optional query parameter "scheme" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheme", ctx.QueryParams(), &params.Scheme)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheme: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfigDescriptions(ctx, params)
	return err
}

// GetConfigDescriptionByURI converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfigDescriptionByURI(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uri" -------------
	var uri string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uri", runtime.ParamLocationPath, ctx.Param("uri"), &uri)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uri: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConfigDescriptionByURIParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfigDescriptionByURI(ctx, uri, params)
	return err
}

// GetBindingsWithDiscoverySupport converts echo context to params.
func (w *ServerInterfaceWrapper) GetBindingsWithDiscoverySupport(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBindingsWithDiscoverySupport(ctx)
	return err
}

// Scan converts echo context to params.
func (w *ServerInterfaceWrapper) Scan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bindingId" -------------
	var bindingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, ctx.Param("bindingId"), &bindingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bindingId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Scan(ctx, bindingId)
	return err
}

// GetEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEventsParams
	// ------------- Optional query parameter "topics" -------------

	err = runtime.BindQueryParameter("form", true, false, "topics", ctx.QueryParams(), &params.Topics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topics: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEvents(ctx, params)
	return err
}

// InitNewStateTacker converts echo context to params.
func (w *ServerInterfaceWrapper) InitNewStateTacker(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InitNewStateTacker(ctx)
	return err
}

// UpdateItemListForStateUpdates converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateItemListForStateUpdates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateItemListForStateUpdates(ctx, connectionId)
	return err
}

// GetGalleryWidgetList converts echo context to params.
func (w *ServerInterfaceWrapper) GetGalleryWidgetList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "galleryName" -------------
	var galleryName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, ctx.Param("galleryName"), &galleryName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter galleryName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGalleryWidgetList(ctx, galleryName)
	return err
}

// GetGalleryWidgetsItem converts echo context to params.
func (w *ServerInterfaceWrapper) GetGalleryWidgetsItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "galleryName" -------------
	var galleryName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, ctx.Param("galleryName"), &galleryName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter galleryName: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGalleryWidgetsItem(ctx, galleryName, id)
	return err
}

// GetIconSets converts echo context to params.
func (w *ServerInterfaceWrapper) GetIconSets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIconSetsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIconSets(ctx, params)
	return err
}

// GetDiscoveredInboxItems converts echo context to params.
func (w *ServerInterfaceWrapper) GetDiscoveredInboxItems(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDiscoveredInboxItems(ctx)
	return err
}

// RemoveItemFromInbox converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveItemFromInbox(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveItemFromInbox(ctx, thingUID)
	return err
}

// ApproveInboxItemById converts echo context to params.
func (w *ServerInterfaceWrapper) ApproveInboxItemById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ApproveInboxItemByIdParams
	// ------------- Optional query parameter "newThingId" -------------

	err = runtime.BindQueryParameter("form", true, false, "newThingId", ctx.QueryParams(), &params.NewThingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter newThingId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApproveInboxItemById(ctx, thingUID, params)
	return err
}

// FlagInboxItemAsIgnored converts echo context to params.
func (w *ServerInterfaceWrapper) FlagInboxItemAsIgnored(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FlagInboxItemAsIgnored(ctx, thingUID)
	return err
}

// RemoveIgnoreFlagOnInboxItem converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveIgnoreFlagOnInboxItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveIgnoreFlagOnInboxItem(ctx, thingUID)
	return err
}

// GetItems converts echo context to params.
func (w *ServerInterfaceWrapper) GetItems(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetItemsParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", ctx.QueryParams(), &params.Metadata)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metadata: %s", err))
	}

	// ------------- Optional query parameter "recursive" -------------

	err = runtime.BindQueryParameter("form", true, false, "recursive", ctx.QueryParams(), &params.Recursive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recursive: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItems(ctx, params)
	return err
}

// AddOrUpdateItemsInRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) AddOrUpdateItemsInRegistry(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddOrUpdateItemsInRegistry(ctx)
	return err
}

// RemoveMemberFromGroupItem converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveMemberFromGroupItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemName" -------------
	var itemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemName", runtime.ParamLocationPath, ctx.Param("itemName"), &itemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// ------------- Path parameter "memberItemName" -------------
	var memberItemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, ctx.Param("memberItemName"), &memberItemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberItemName: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveMemberFromGroupItem(ctx, itemName, memberItemName)
	return err
}

// AddMemberToGroupItem converts echo context to params.
func (w *ServerInterfaceWrapper) AddMemberToGroupItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemName" -------------
	var itemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemName", runtime.ParamLocationPath, ctx.Param("itemName"), &itemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// ------------- Path parameter "memberItemName" -------------
	var memberItemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, ctx.Param("memberItemName"), &memberItemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberItemName: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddMemberToGroupItem(ctx, itemName, memberItemName)
	return err
}

// RemoveItemFromRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveItemFromRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveItemFromRegistry(ctx, itemname)
	return err
}

// GetItemByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetItemByNameParams
	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", ctx.QueryParams(), &params.Metadata)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metadata: %s", err))
	}

	// ------------- Optional query parameter "recursive" -------------

	err = runtime.BindQueryParameter("form", true, false, "recursive", ctx.QueryParams(), &params.Recursive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recursive: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemByName(ctx, itemname, params)
	return err
}

// SendItemCommand converts echo context to params.
func (w *ServerInterfaceWrapper) SendItemCommand(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendItemCommand(ctx, itemname)
	return err
}

// AddOrUpdateItemInRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) AddOrUpdateItemInRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddOrUpdateItemInRegistryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddOrUpdateItemInRegistry(ctx, itemname, params)
	return err
}

// RemoveMetadataFromItem converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveMetadataFromItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveMetadataFromItem(ctx, itemname, namespace)
	return err
}

// AddMetadataToItem converts echo context to params.
func (w *ServerInterfaceWrapper) AddMetadataToItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddMetadataToItem(ctx, itemname, namespace)
	return err
}

// GetItemState converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemState(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemState(ctx, itemname)
	return err
}

// UpdateItemState converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateItemState(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateItemStateParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateItemState(ctx, itemname, params)
	return err
}

// RemoveTagFromItem converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveTagFromItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tag", runtime.ParamLocationPath, ctx.Param("tag"), &tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveTagFromItem(ctx, itemname, tag)
	return err
}

// AddTagToItem converts echo context to params.
func (w *ServerInterfaceWrapper) AddTagToItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tag", runtime.ParamLocationPath, ctx.Param("tag"), &tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddTagToItem(ctx, itemname, tag)
	return err
}

// GetItemLinks converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemLinks(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetItemLinksParams
	// ------------- Optional query parameter "channelUID" -------------

	err = runtime.BindQueryParameter("form", true, false, "channelUID", ctx.QueryParams(), &params.ChannelUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelUID: %s", err))
	}

	// ------------- Optional query parameter "itemName" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemName", ctx.QueryParams(), &params.ItemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemLinks(ctx, params)
	return err
}

// UnlinkItemFromChannel converts echo context to params.
func (w *ServerInterfaceWrapper) UnlinkItemFromChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemName" -------------
	var itemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemName", runtime.ParamLocationPath, ctx.Param("itemName"), &itemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// ------------- Path parameter "channelUID" -------------
	var channelUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, ctx.Param("channelUID"), &channelUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UnlinkItemFromChannel(ctx, itemName, channelUID)
	return err
}

// GetItemLink converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemLink(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemName" -------------
	var itemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemName", runtime.ParamLocationPath, ctx.Param("itemName"), &itemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// ------------- Path parameter "channelUID" -------------
	var channelUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, ctx.Param("channelUID"), &channelUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemLink(ctx, itemName, channelUID)
	return err
}

// LinkItemToChannel converts echo context to params.
func (w *ServerInterfaceWrapper) LinkItemToChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemName" -------------
	var itemName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemName", runtime.ParamLocationPath, ctx.Param("itemName"), &itemName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemName: %s", err))
	}

	// ------------- Path parameter "channelUID" -------------
	var channelUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, ctx.Param("channelUID"), &channelUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LinkItemToChannel(ctx, itemName, channelUID)
	return err
}

// GetModuleTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetModuleTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetModuleTypesParams
	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetModuleTypes(ctx, params)
	return err
}

// GetModuleTypeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetModuleTypeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "moduleTypeUID" -------------
	var moduleTypeUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleTypeUID", runtime.ParamLocationPath, ctx.Param("moduleTypeUID"), &moduleTypeUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moduleTypeUID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetModuleTypeByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetModuleTypeById(ctx, moduleTypeUID, params)
	return err
}

// GetPersistenceServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetPersistenceServices(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPersistenceServicesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPersistenceServices(ctx, params)
	return err
}

// GetItemsForPersistenceService converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemsForPersistenceService(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetItemsForPersistenceServiceParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemsForPersistenceService(ctx, params)
	return err
}

// DeleteItemFromPersistenceService converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteItemFromPersistenceService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteItemFromPersistenceServiceParams
	// ------------- Required query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, true, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Required query parameter "starttime" -------------

	err = runtime.BindQueryParameter("form", true, true, "starttime", ctx.QueryParams(), &params.Starttime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starttime: %s", err))
	}

	// ------------- Required query parameter "endtime" -------------

	err = runtime.BindQueryParameter("form", true, true, "endtime", ctx.QueryParams(), &params.Endtime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endtime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteItemFromPersistenceService(ctx, itemname, params)
	return err
}

// GetItemDataFromPersistenceService converts echo context to params.
func (w *ServerInterfaceWrapper) GetItemDataFromPersistenceService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetItemDataFromPersistenceServiceParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Optional query parameter "starttime" -------------

	err = runtime.BindQueryParameter("form", true, false, "starttime", ctx.QueryParams(), &params.Starttime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starttime: %s", err))
	}

	// ------------- Optional query parameter "endtime" -------------

	err = runtime.BindQueryParameter("form", true, false, "endtime", ctx.QueryParams(), &params.Endtime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endtime: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "pagelength" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagelength", ctx.QueryParams(), &params.Pagelength)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pagelength: %s", err))
	}

	// ------------- Optional query parameter "boundary" -------------

	err = runtime.BindQueryParameter("form", true, false, "boundary", ctx.QueryParams(), &params.Boundary)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter boundary: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetItemDataFromPersistenceService(ctx, itemname, params)
	return err
}

// StoreItemDataInPersistenceService converts echo context to params.
func (w *ServerInterfaceWrapper) StoreItemDataInPersistenceService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "itemname" -------------
	var itemname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemname", runtime.ParamLocationPath, ctx.Param("itemname"), &itemname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemname: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params StoreItemDataInPersistenceServiceParams
	// ------------- Optional query parameter "serviceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "serviceId", ctx.QueryParams(), &params.ServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Required query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, true, "time", ctx.QueryParams(), &params.Time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	// ------------- Required query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, true, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StoreItemDataInPersistenceService(ctx, itemname, params)
	return err
}

// GetProfileTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetProfileTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProfileTypesParams
	// ------------- Optional query parameter "channelTypeUID" -------------

	err = runtime.BindQueryParameter("form", true, false, "channelTypeUID", ctx.QueryParams(), &params.ChannelTypeUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelTypeUID: %s", err))
	}

	// ------------- Optional query parameter "itemType" -------------

	err = runtime.BindQueryParameter("form", true, false, "itemType", ctx.QueryParams(), &params.ItemType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter itemType: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProfileTypes(ctx, params)
	return err
}

// GetRules converts echo context to params.
func (w *ServerInterfaceWrapper) GetRules(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesParams
	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "summary" -------------

	err = runtime.BindQueryParameter("form", true, false, "summary", ctx.QueryParams(), &params.Summary)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter summary: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRules(ctx, params)
	return err
}

// CreateRule converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRule(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRule(ctx)
	return err
}

// GetScheduleRuleSimulations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScheduleRuleSimulations(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScheduleRuleSimulationsParams
	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "until" -------------

	err = runtime.BindQueryParameter("form", true, false, "until", ctx.QueryParams(), &params.Until)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScheduleRuleSimulations(ctx, params)
	return err
}

// DeleteRule converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteRule(ctx, ruleUID)
	return err
}

// GetRuleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleById(ctx, ruleUID)
	return err
}

// UpdateRule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRule(ctx, ruleUID)
	return err
}

// GetRuleActions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleActions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleActions(ctx, ruleUID)
	return err
}

// GetRuleConditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleConditions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleConditions(ctx, ruleUID)
	return err
}

// GetRuleConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleConfiguration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleConfiguration(ctx, ruleUID)
	return err
}

// UpdateRuleConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRuleConfiguration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRuleConfiguration(ctx, ruleUID)
	return err
}

// EnableRule converts echo context to params.
func (w *ServerInterfaceWrapper) EnableRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EnableRule(ctx, ruleUID)
	return err
}

// RunRuleNow converts echo context to params.
func (w *ServerInterfaceWrapper) RunRuleNow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunRuleNow(ctx, ruleUID)
	return err
}

// GetRuleTriggers converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleTriggers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleTriggers(ctx, ruleUID)
	return err
}

// GetRuleModuleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleModuleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	// ------------- Path parameter "moduleCategory" -------------
	var moduleCategory string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, ctx.Param("moduleCategory"), &moduleCategory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moduleCategory: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleModuleById(ctx, ruleUID, moduleCategory, id)
	return err
}

// GetRuleModuleConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleModuleConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	// ------------- Path parameter "moduleCategory" -------------
	var moduleCategory string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, ctx.Param("moduleCategory"), &moduleCategory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moduleCategory: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleModuleConfig(ctx, ruleUID, moduleCategory, id)
	return err
}

// GetRuleModuleConfigParameter converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuleModuleConfigParameter(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	// ------------- Path parameter "moduleCategory" -------------
	var moduleCategory string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, ctx.Param("moduleCategory"), &moduleCategory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moduleCategory: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "param" -------------
	var param string

	err = runtime.BindStyledParameterWithLocation("simple", false, "param", runtime.ParamLocationPath, ctx.Param("param"), &param)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter param: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuleModuleConfigParameter(ctx, ruleUID, moduleCategory, id, param)
	return err
}

// SetRuleModuleConfigParameter converts echo context to params.
func (w *ServerInterfaceWrapper) SetRuleModuleConfigParameter(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleUID" -------------
	var ruleUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ctx.Param("ruleUID"), &ruleUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleUID: %s", err))
	}

	// ------------- Path parameter "moduleCategory" -------------
	var moduleCategory string

	err = runtime.BindStyledParameterWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, ctx.Param("moduleCategory"), &moduleCategory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moduleCategory: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "param" -------------
	var param string

	err = runtime.BindStyledParameterWithLocation("simple", false, "param", runtime.ParamLocationPath, ctx.Param("param"), &param)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter param: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetRuleModuleConfigParameter(ctx, ruleUID, moduleCategory, id, param)
	return err
}

// GetServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetServices(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServicesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServices(ctx, params)
	return err
}

// GetServicesById converts echo context to params.
func (w *ServerInterfaceWrapper) GetServicesById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServicesByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServicesById(ctx, serviceId, params)
	return err
}

// DeleteServiceConfig converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteServiceConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteServiceConfig(ctx, serviceId)
	return err
}

// GetServiceConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetServiceConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServiceConfig(ctx, serviceId)
	return err
}

// UpdateServiceConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateServiceConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateServiceConfigParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateServiceConfig(ctx, serviceId, params)
	return err
}

// GetServiceContext converts echo context to params.
func (w *ServerInterfaceWrapper) GetServiceContext(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServiceContextParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServiceContext(ctx, serviceId, params)
	return err
}

// GetSitemaps converts echo context to params.
func (w *ServerInterfaceWrapper) GetSitemaps(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSitemaps(ctx)
	return err
}

// CreateSitemapEventSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSitemapEventSubscription(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSitemapEventSubscription(ctx)
	return err
}

// GetSitemapEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetSitemapEvents(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "subscriptionid" -------------
	var subscriptionid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "subscriptionid", runtime.ParamLocationPath, ctx.Param("subscriptionid"), &subscriptionid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscriptionid: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSitemapEventsParams
	// ------------- Optional query parameter "sitemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sitemap", ctx.QueryParams(), &params.Sitemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitemap: %s", err))
	}

	// ------------- Optional query parameter "pageid" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageid", ctx.QueryParams(), &params.Pageid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSitemapEvents(ctx, subscriptionid, params)
	return err
}

// GetSitemapByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetSitemapByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sitemapname" -------------
	var sitemapname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, ctx.Param("sitemapname"), &sitemapname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitemapname: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSitemapByNameParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "jsoncallback" -------------

	err = runtime.BindQueryParameter("form", true, false, "jsoncallback", ctx.QueryParams(), &params.Jsoncallback)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jsoncallback: %s", err))
	}

	// ------------- Optional query parameter "includeHidden" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeHidden", ctx.QueryParams(), &params.IncludeHidden)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeHidden: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSitemapByName(ctx, sitemapname, params)
	return err
}

// PollDataForSitemap converts echo context to params.
func (w *ServerInterfaceWrapper) PollDataForSitemap(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sitemapname" -------------
	var sitemapname string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, ctx.Param("sitemapname"), &sitemapname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sitemapname: %s", err))
	}

	// ------------- Path parameter "pageid" -------------
	var pageid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pageid", runtime.ParamLocationPath, ctx.Param("pageid"), &pageid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageid: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PollDataForSitemapParams
	// ------------- Optional query parameter "subscriptionid" -------------

	err = runtime.BindQueryParameter("form", true, false, "subscriptionid", ctx.QueryParams(), &params.Subscriptionid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscriptionid: %s", err))
	}

	// ------------- Optional query parameter "includeHidden" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeHidden", ctx.QueryParams(), &params.IncludeHidden)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeHidden: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PollDataForSitemap(ctx, sitemapname, pageid, params)
	return err
}

// GetSystemInformation converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemInformation(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSystemInformation(ctx)
	return err
}

// GetTemplates converts echo context to params.
func (w *ServerInterfaceWrapper) GetTemplates(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplatesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTemplates(ctx, params)
	return err
}

// GetTemplateById converts echo context to params.
func (w *ServerInterfaceWrapper) GetTemplateById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "templateUID" -------------
	var templateUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "templateUID", runtime.ParamLocationPath, ctx.Param("templateUID"), &templateUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter templateUID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTemplateByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTemplateById(ctx, templateUID, params)
	return err
}

// GetThingTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingTypes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingTypesParams
	// ------------- Optional query parameter "bindingId" -------------

	err = runtime.BindQueryParameter("form", true, false, "bindingId", ctx.QueryParams(), &params.BindingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bindingId: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingTypes(ctx, params)
	return err
}

// GetThingTypeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingTypeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingTypeUID" -------------
	var thingTypeUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingTypeUID", runtime.ParamLocationPath, ctx.Param("thingTypeUID"), &thingTypeUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingTypeUID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingTypeByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingTypeById(ctx, thingTypeUID, params)
	return err
}

// GetThings converts echo context to params.
func (w *ServerInterfaceWrapper) GetThings(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingsParams
	// ------------- Optional query parameter "summary" -------------

	err = runtime.BindQueryParameter("form", true, false, "summary", ctx.QueryParams(), &params.Summary)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter summary: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThings(ctx, params)
	return err
}

// CreateThingInRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) CreateThingInRegistry(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateThingInRegistryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateThingInRegistry(ctx, params)
	return err
}

// RemoveThingById converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveThingById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RemoveThingByIdParams
	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveThingById(ctx, thingUID, params)
	return err
}

// GetThingById converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingById(ctx, thingUID, params)
	return err
}

// UpdateThing converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateThing(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateThingParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateThing(ctx, thingUID, params)
	return err
}

// UpdateThingConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateThingConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateThingConfigParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateThingConfig(ctx, thingUID, params)
	return err
}

// GetThingConfigStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingConfigStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingConfigStatusParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingConfigStatus(ctx, thingUID, params)
	return err
}

// EnableThing converts echo context to params.
func (w *ServerInterfaceWrapper) EnableThing(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params EnableThingParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EnableThing(ctx, thingUID, params)
	return err
}

// GetThingFirmwareStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingFirmwareStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingFirmwareStatusParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingFirmwareStatus(ctx, thingUID, params)
	return err
}

// UpdateThingFirmware converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateThingFirmware(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	// ------------- Path parameter "firmwareVersion" -------------
	var firmwareVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "firmwareVersion", runtime.ParamLocationPath, ctx.Param("firmwareVersion"), &firmwareVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter firmwareVersion: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateThingFirmwareParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateThingFirmware(ctx, thingUID, firmwareVersion, params)
	return err
}

// GetAvailableFirmwaresForThing converts echo context to params.
func (w *ServerInterfaceWrapper) GetAvailableFirmwaresForThing(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAvailableFirmwaresForThingParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAvailableFirmwaresForThing(ctx, thingUID, params)
	return err
}

// GetThingStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetThingStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thingUID" -------------
	var thingUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, ctx.Param("thingUID"), &thingUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thingUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetThingStatusParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThingStatus(ctx, thingUID, params)
	return err
}

// GetRegisteredUIComponentsInNamespace converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegisteredUIComponentsInNamespace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRegisteredUIComponentsInNamespaceParams
	// ------------- Optional query parameter "summary" -------------

	err = runtime.BindQueryParameter("form", true, false, "summary", ctx.QueryParams(), &params.Summary)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter summary: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRegisteredUIComponentsInNamespace(ctx, namespace, params)
	return err
}

// AddUIComponentToNamespace converts echo context to params.
func (w *ServerInterfaceWrapper) AddUIComponentToNamespace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddUIComponentToNamespace(ctx, namespace)
	return err
}

// RemoveUIComponentFromNamespace converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveUIComponentFromNamespace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "componentUID" -------------
	var componentUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, ctx.Param("componentUID"), &componentUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter componentUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveUIComponentFromNamespace(ctx, namespace, componentUID)
	return err
}

// GetUIComponentInNamespace converts echo context to params.
func (w *ServerInterfaceWrapper) GetUIComponentInNamespace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "componentUID" -------------
	var componentUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, ctx.Param("componentUID"), &componentUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter componentUID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUIComponentInNamespace(ctx, namespace, componentUID)
	return err
}

// UpdateUIComponentInNamespace converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUIComponentInNamespace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithLocation("simple", false, "namespace", runtime.ParamLocationPath, ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "componentUID" -------------
	var componentUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, ctx.Param("componentUID"), &componentUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter componentUID: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUIComponentInNamespace(ctx, namespace, componentUID)
	return err
}

// GetUITiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetUITiles(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUITiles(ctx)
	return err
}

// GetUUID converts echo context to params.
func (w *ServerInterfaceWrapper) GetUUID(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUUID(ctx)
	return err
}

// GetDefaultVoice converts echo context to params.
func (w *ServerInterfaceWrapper) GetDefaultVoice(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDefaultVoice(ctx)
	return err
}

// GetVoiceInterpreters converts echo context to params.
func (w *ServerInterfaceWrapper) GetVoiceInterpreters(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVoiceInterpretersParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVoiceInterpreters(ctx, params)
	return err
}

// InterpretTextByDefaultInterpreter converts echo context to params.
func (w *ServerInterfaceWrapper) InterpretTextByDefaultInterpreter(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params InterpretTextByDefaultInterpreterParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InterpretTextByDefaultInterpreter(ctx, params)
	return err
}

// GetVoiceInterpreterByUID converts echo context to params.
func (w *ServerInterfaceWrapper) GetVoiceInterpreterByUID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVoiceInterpreterByUIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVoiceInterpreterByUID(ctx, id, params)
	return err
}

// InterpretText converts echo context to params.
func (w *ServerInterfaceWrapper) InterpretText(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InterpretTextParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = &AcceptLanguage
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InterpretText(ctx, id, params)
	return err
}

// TextToSpeech converts echo context to params.
func (w *ServerInterfaceWrapper) TextToSpeech(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TextToSpeechParams
	// ------------- Optional query parameter "voiceid" -------------

	err = runtime.BindQueryParameter("form", true, false, "voiceid", ctx.QueryParams(), &params.Voiceid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter voiceid: %s", err))
	}

	// ------------- Optional query parameter "sinkid" -------------

	err = runtime.BindQueryParameter("form", true, false, "sinkid", ctx.QueryParams(), &params.Sinkid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sinkid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TextToSpeech(ctx, params)
	return err
}

// GetVoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetVoices(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVoices(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetRoot)
	router.GET(baseURL+"/addons", wrapper.GetAddons)
	router.GET(baseURL+"/addons/services", wrapper.GetAddonTypes)
	router.GET(baseURL+"/addons/types", wrapper.GetAddonServices)
	router.POST(baseURL+"/addons/url/:url/install", wrapper.InstallAddonFromURL)
	router.GET(baseURL+"/addons/:addonId", wrapper.GetAddonById)
	router.POST(baseURL+"/addons/:addonId/install", wrapper.InstallAddonById)
	router.POST(baseURL+"/addons/:addonId/uninstall", wrapper.UninstallAddon)
	router.GET(baseURL+"/audio/defaultsink", wrapper.GetAudioDefaultSink)
	router.GET(baseURL+"/audio/defaultsource", wrapper.GetAudioDefaultSource)
	router.GET(baseURL+"/audio/sinks", wrapper.GetAudioSinks)
	router.GET(baseURL+"/audio/sources", wrapper.GetAudioSources)
	router.GET(baseURL+"/auth/apitokens", wrapper.GetApiTokens)
	router.DELETE(baseURL+"/auth/apitokens/:name", wrapper.RemoveApiToken)
	router.POST(baseURL+"/auth/logout", wrapper.DeleteSession)
	router.GET(baseURL+"/auth/sessions", wrapper.GetSessionsForCurrentUser)
	router.POST(baseURL+"/auth/token", wrapper.GetOAuthToken)
	router.GET(baseURL+"/bindings", wrapper.GetBindings)
	router.GET(baseURL+"/bindings/:bindingId/config", wrapper.GetBindingConfiguration)
	router.PUT(baseURL+"/bindings/:bindingId/config", wrapper.UpdateBindingConfiguration)
	router.GET(baseURL+"/channel-types", wrapper.GetChannelTypes)
	router.GET(baseURL+"/channel-types/:channelTypeUID", wrapper.GetChannelTypeByUID)
	router.GET(baseURL+"/channel-types/:channelTypeUID/linkableItemTypes", wrapper.GetLinkableItemTypesByChannelTypeUID)
	router.GET(baseURL+"/config-descriptions", wrapper.GetConfigDescriptions)
	router.GET(baseURL+"/config-descriptions/:uri", wrapper.GetConfigDescriptionByURI)
	router.GET(baseURL+"/discovery", wrapper.GetBindingsWithDiscoverySupport)
	router.POST(baseURL+"/discovery/bindings/:bindingId/scan", wrapper.Scan)
	router.GET(baseURL+"/events", wrapper.GetEvents)
	router.GET(baseURL+"/events/states", wrapper.InitNewStateTacker)
	router.POST(baseURL+"/events/states/:connectionId", wrapper.UpdateItemListForStateUpdates)
	router.GET(baseURL+"/habpanel/gallery/:galleryName/widgets", wrapper.GetGalleryWidgetList)
	router.GET(baseURL+"/habpanel/gallery/:galleryName/widgets/:id", wrapper.GetGalleryWidgetsItem)
	router.GET(baseURL+"/iconsets", wrapper.GetIconSets)
	router.GET(baseURL+"/inbox", wrapper.GetDiscoveredInboxItems)
	router.DELETE(baseURL+"/inbox/:thingUID", wrapper.RemoveItemFromInbox)
	router.POST(baseURL+"/inbox/:thingUID/approve", wrapper.ApproveInboxItemById)
	router.POST(baseURL+"/inbox/:thingUID/ignore", wrapper.FlagInboxItemAsIgnored)
	router.POST(baseURL+"/inbox/:thingUID/unignore", wrapper.RemoveIgnoreFlagOnInboxItem)
	router.GET(baseURL+"/items", wrapper.GetItems)
	router.PUT(baseURL+"/items", wrapper.AddOrUpdateItemsInRegistry)
	router.DELETE(baseURL+"/items/:itemName/members/:memberItemName", wrapper.RemoveMemberFromGroupItem)
	router.PUT(baseURL+"/items/:itemName/members/:memberItemName", wrapper.AddMemberToGroupItem)
	router.DELETE(baseURL+"/items/:itemname", wrapper.RemoveItemFromRegistry)
	router.GET(baseURL+"/items/:itemname", wrapper.GetItemByName)
	router.POST(baseURL+"/items/:itemname", wrapper.SendItemCommand)
	router.PUT(baseURL+"/items/:itemname", wrapper.AddOrUpdateItemInRegistry)
	router.DELETE(baseURL+"/items/:itemname/metadata/:namespace", wrapper.RemoveMetadataFromItem)
	router.PUT(baseURL+"/items/:itemname/metadata/:namespace", wrapper.AddMetadataToItem)
	router.GET(baseURL+"/items/:itemname/state", wrapper.GetItemState)
	router.PUT(baseURL+"/items/:itemname/state", wrapper.UpdateItemState)
	router.DELETE(baseURL+"/items/:itemname/tags/:tag", wrapper.RemoveTagFromItem)
	router.PUT(baseURL+"/items/:itemname/tags/:tag", wrapper.AddTagToItem)
	router.GET(baseURL+"/links", wrapper.GetItemLinks)
	router.DELETE(baseURL+"/links/:itemName/:channelUID", wrapper.UnlinkItemFromChannel)
	router.GET(baseURL+"/links/:itemName/:channelUID", wrapper.GetItemLink)
	router.PUT(baseURL+"/links/:itemName/:channelUID", wrapper.LinkItemToChannel)
	router.GET(baseURL+"/module-types", wrapper.GetModuleTypes)
	router.GET(baseURL+"/module-types/:moduleTypeUID", wrapper.GetModuleTypeById)
	router.GET(baseURL+"/persistence", wrapper.GetPersistenceServices)
	router.GET(baseURL+"/persistence/items", wrapper.GetItemsForPersistenceService)
	router.DELETE(baseURL+"/persistence/items/:itemname", wrapper.DeleteItemFromPersistenceService)
	router.GET(baseURL+"/persistence/items/:itemname", wrapper.GetItemDataFromPersistenceService)
	router.PUT(baseURL+"/persistence/items/:itemname", wrapper.StoreItemDataInPersistenceService)
	router.GET(baseURL+"/profile-types", wrapper.GetProfileTypes)
	router.GET(baseURL+"/rules", wrapper.GetRules)
	router.POST(baseURL+"/rules", wrapper.CreateRule)
	router.GET(baseURL+"/rules/schedule/simulations", wrapper.GetScheduleRuleSimulations)
	router.DELETE(baseURL+"/rules/:ruleUID", wrapper.DeleteRule)
	router.GET(baseURL+"/rules/:ruleUID", wrapper.GetRuleById)
	router.PUT(baseURL+"/rules/:ruleUID", wrapper.UpdateRule)
	router.GET(baseURL+"/rules/:ruleUID/actions", wrapper.GetRuleActions)
	router.GET(baseURL+"/rules/:ruleUID/conditions", wrapper.GetRuleConditions)
	router.GET(baseURL+"/rules/:ruleUID/config", wrapper.GetRuleConfiguration)
	router.PUT(baseURL+"/rules/:ruleUID/config", wrapper.UpdateRuleConfiguration)
	router.POST(baseURL+"/rules/:ruleUID/enable", wrapper.EnableRule)
	router.POST(baseURL+"/rules/:ruleUID/runnow", wrapper.RunRuleNow)
	router.GET(baseURL+"/rules/:ruleUID/triggers", wrapper.GetRuleTriggers)
	router.GET(baseURL+"/rules/:ruleUID/:moduleCategory/:id", wrapper.GetRuleModuleById)
	router.GET(baseURL+"/rules/:ruleUID/:moduleCategory/:id/config", wrapper.GetRuleModuleConfig)
	router.GET(baseURL+"/rules/:ruleUID/:moduleCategory/:id/config/:param", wrapper.GetRuleModuleConfigParameter)
	router.PUT(baseURL+"/rules/:ruleUID/:moduleCategory/:id/config/:param", wrapper.SetRuleModuleConfigParameter)
	router.GET(baseURL+"/services", wrapper.GetServices)
	router.GET(baseURL+"/services/:serviceId", wrapper.GetServicesById)
	router.DELETE(baseURL+"/services/:serviceId/config", wrapper.DeleteServiceConfig)
	router.GET(baseURL+"/services/:serviceId/config", wrapper.GetServiceConfig)
	router.PUT(baseURL+"/services/:serviceId/config", wrapper.UpdateServiceConfig)
	router.GET(baseURL+"/services/:serviceId/contexts", wrapper.GetServiceContext)
	router.GET(baseURL+"/sitemaps", wrapper.GetSitemaps)
	router.POST(baseURL+"/sitemaps/events/subscribe", wrapper.CreateSitemapEventSubscription)
	router.GET(baseURL+"/sitemaps/events/:subscriptionid", wrapper.GetSitemapEvents)
	router.GET(baseURL+"/sitemaps/:sitemapname", wrapper.GetSitemapByName)
	router.GET(baseURL+"/sitemaps/:sitemapname/:pageid", wrapper.PollDataForSitemap)
	router.GET(baseURL+"/systeminfo", wrapper.GetSystemInformation)
	router.GET(baseURL+"/templates", wrapper.GetTemplates)
	router.GET(baseURL+"/templates/:templateUID", wrapper.GetTemplateById)
	router.GET(baseURL+"/thing-types", wrapper.GetThingTypes)
	router.GET(baseURL+"/thing-types/:thingTypeUID", wrapper.GetThingTypeById)
	router.GET(baseURL+"/things", wrapper.GetThings)
	router.POST(baseURL+"/things", wrapper.CreateThingInRegistry)
	router.DELETE(baseURL+"/things/:thingUID", wrapper.RemoveThingById)
	router.GET(baseURL+"/things/:thingUID", wrapper.GetThingById)
	router.PUT(baseURL+"/things/:thingUID", wrapper.UpdateThing)
	router.PUT(baseURL+"/things/:thingUID/config", wrapper.UpdateThingConfig)
	router.GET(baseURL+"/things/:thingUID/config/status", wrapper.GetThingConfigStatus)
	router.PUT(baseURL+"/things/:thingUID/enable", wrapper.EnableThing)
	router.GET(baseURL+"/things/:thingUID/firmware/status", wrapper.GetThingFirmwareStatus)
	router.PUT(baseURL+"/things/:thingUID/firmware/:firmwareVersion", wrapper.UpdateThingFirmware)
	router.GET(baseURL+"/things/:thingUID/firmwares", wrapper.GetAvailableFirmwaresForThing)
	router.GET(baseURL+"/things/:thingUID/status", wrapper.GetThingStatus)
	router.GET(baseURL+"/ui/components/:namespace", wrapper.GetRegisteredUIComponentsInNamespace)
	router.POST(baseURL+"/ui/components/:namespace", wrapper.AddUIComponentToNamespace)
	router.DELETE(baseURL+"/ui/components/:namespace/:componentUID", wrapper.RemoveUIComponentFromNamespace)
	router.GET(baseURL+"/ui/components/:namespace/:componentUID", wrapper.GetUIComponentInNamespace)
	router.PUT(baseURL+"/ui/components/:namespace/:componentUID", wrapper.UpdateUIComponentInNamespace)
	router.GET(baseURL+"/ui/tiles", wrapper.GetUITiles)
	router.GET(baseURL+"/uuid", wrapper.GetUUID)
	router.GET(baseURL+"/voice/defaultvoice", wrapper.GetDefaultVoice)
	router.GET(baseURL+"/voice/interpreters", wrapper.GetVoiceInterpreters)
	router.POST(baseURL+"/voice/interpreters", wrapper.InterpretTextByDefaultInterpreter)
	router.GET(baseURL+"/voice/interpreters/:id", wrapper.GetVoiceInterpreterByUID)
	router.POST(baseURL+"/voice/interpreters/:id", wrapper.InterpretText)
	router.POST(baseURL+"/voice/say", wrapper.TextToSpeech)
	router.GET(baseURL+"/voice/voices", wrapper.GetVoices)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e28jt5LvVyF0LzBnFx4rJzm5uDv/eWx5Rli/IMmT3Q2CAdVNSTxukQrJtq1j+Lsv",
	"+Oon2Q+p9bAz/yQeNZtNVv2qWFUsFl96AV2uKEFE8N6nlx4PFmgJ1Z9ngcCUyL9WjK4QExip3wNKZnge",
	"M2gf/1+GZr1Pvf/TT7vqm37657nGrye9EPGA4ZV9V6xXqPepxwXDZC6f49D9M1nFeoQwDLF8G0Z3uWGV",
	"XjE/0Ok/USDkDxGcosjb9H544Xjm6kcT5mJy24A2NaNNOy39cLSEakqlMHShB8ZiQZmz8ykMHuaMxiQ8",
	"p5GnjSbwRUqb+9HQ15CgwEu9gBKBiJi45yOfx0QwH8XqeBMiAXGEwosNebiEc3SFyYOHw1zAKELZd6eU",
	"RggqAXtA6yfKQvfA/ZyNcIAIR55nnqEsoYgZFmvnwwLfNxYE4ePRI2J4hlF4VoRUhhqPiHE39b2YtZjI",
	"j9/DKh9Bnb3HIaZjTB6cqqOzD9CYBWhXn/iMSYjJfEhm1PmJCvFuLLobaj4Cl0110/kCEoIi3wzo/SqE",
	"At3RCAdubAe6g4l33TjpdimYwTgSEzjXbBRoWanJIWNw3TvpxQT/GaOhbi5YjLZYVgRaepXlAyZhS3XT",
	"SjlULFWxc7xVPEczTLB3AYfhIySBT7cGUKA5ZesuYbt7GnEBBSosRVU227jYXnbaBfbamVmGYV8YjVc1",
	"XDPimB9hpVnqAkNxEt3ztGKaUricc/Pply2QGtDlEpKwBSTOy280oU7XSgMyuEQCMYWJFtwurjx3uY48",
	"vE++1sWHPN84EtF04tIJkqK7o9rcqsdtyJR5rUyWitHcVg9ke2GkRGvZH26vnzY/PN9aQuW1gJNg70+Z",
	"xQxvSqGk69YWmfTjn4XHIFNm80bG2gxHArFzhgViGDam2WX+NQeR5pJJN25Xpdo/X2IxoRlVWybGEj7j",
	"ZbzMPCTxcoqYeoaJ/1kcCbyKkKdX8/RKjkA2mVG2hKL3qYeJ+OXnXjJHTASa6x6Jb4K05VKRAMO3WEho",
	"C4GYm40MwfCWRGv3zBj6M8bMBy0u0GqM/4WcJLPqABFJ0997k8F/TXonveHNZPBlMOqd9C4G58Prs6ve",
	"Se/z7e3V4Oym98dJeXwxwW58ygdXXjCoyMcaTt0saydxm7hB9UL3DUYxOpzkeTTUjoXPJ3hvXOi8S8ru",
	"5I4fs9xtL3PJSt2p4FXLlR/dbQJnakrSC4n5NeIczh2h0mX6wO/CeaWQq87PaYgawr4IieHN5e3o+mwy",
	"vL3pnfR+OxvdDG++9E56g9HoViLkbnBzIX8p48I/45hJZTtG7BF7Yqs1DnfD0GfrGFGVFqmcjtvJ6SZm",
	"7/rwBeYBfURsPUI8joSThlOGw7k3oDqL4DzL55vBb1Lyv9zcjgYXTinvKLRW4aowtGKIIyIUPc3bbgyI",
	"BSbzqoCxatDcHRsQhoMFCn/Esg8dy44weUDh0M5kqyntPy5ucSTHYbB05dujMlDZA0xQiIXPvtUcvGm+",
	"amWnuIny7iZaWj2lxDRtg6FaWLrXDCRgCAXcjkOkagGveHIUGxEMEi5NCxSOvaNtEfGxABvFkds6gEE7",
	"CzxNMXGwPLCBuFaxnBBXd5k3UHYYJtpjpLBa5Ei1CVo3cclsbQkPyYx2h020XEVQ+M0EhufzNnG8iX7B",
	"F7TzLJKPmOMpjkxyh7W5vg3Hw89Xg95J7+vw4mIgDezBf90NRpOG1rQVlIm0dVptd1Xbhq03AB3W026h",
	"Wg3FGWbLJ8gMnupjHdnWZuwVCwENoFdEutxkNpJQh0fJ+4LgVNvGru9dlsJE+Zl4hfvRE5mq/4gTrx19",
	"RzPUa3TNUUTnG7n9Sxr6XEf5ZITkD4HwRRxWDKloDccCffPmUjXwbh4RCT2JQe1ytMrgL1Es1d/l+I70",
	"hqQcfmv10S8wihBbS03dKudJPzp7hAKyexZVtPHGQwKGoEDhhTFTkoCI9Oo+CrxEvZPOclFU4qFvnBF+",
	"0PNtEJNZUS6atmUIhp65Cywi5OdjW6o8YvTUbFQVGPhNrkOCX2Eu3HB49wzzc2VLAksX6DIm/vRqr7JV",
	"YcVWnpN3AJs5iTMz7LrFrzTHLVw/9Z43kNE63tthkldDrfoVc0HZ+gIK+FmuN05F7tMMy1J8+P/9oyHQ",
	"vsZLSK4gmcdwjoZEILZi3q2w1iFZaW5FaBcpOcOAkjES5THW7qkpKuWHZE36OxUcH3/74gyhNmB4Bzlw",
	"xxV7ahldkoO3SHYN3IZaGvklRZFw5SRCAVcUmwM7LaSbChgxFHgOB7imJpnh2BfwZuTHrCnHr+Fq5XMB",
	"u0rmujZxrop8pe2A0sbEv6ZhHKEjSSvrKiVMT+pI88E6yeXSM/Qm5+4zbrb5Bm8n6/p+A0V3cO45wxK0",
	"RAGCM7dr642PryBDRNQnSegRGmOExsL9Gb+1/KQ9icaI0Z6HEx1uEuZTp0qk9AOmjWJzJIvs6kvSZecC",
	"kUBB08aaihIZk6YJMwiyCCMumrtpERSt2rdIrcjMrirPYJfK7o7RGa7QdhvsjfJ4taJM6L032XFLH6f5",
	"PuaIUuH2IiJrxTSSMm3zuHbalF3v2VGDPGZoiYgYr7mJCpSTomIicdIkRjrKNG0dIZOUuB+e216dBlb6",
	"yGNJb7dky++1XwGNauMRrc7jbsTHLAUc3CzPoRPnFy8RF3C5aq4i/MZ0c+g7LcvN9hy73nBstK3SyubN",
	"vd2x6bWJ3bVUJmLzrxtPwPGlHQdmdrSxePhdxR/b7se17f42cXwUG+QSyoNnFMRukz1stanAzLpQl8Xg",
	"H8o4t6vbLuiY7sJZ4tzfDG+Gk+HZ1fB/Bhcqa9v8SyfoDi8U4Ub3Nzfu/Fzb54Uqr5HLBb29UTQ/u7m4",
	"Goy+Xw/H4+HNl+825df+nv1g8vD89uZy+OV+pDKGk18ng+u7q7PJoNTX8Obb2dXw4vvoXo32Yjg++3zl",
	"TEB1EzVnAxbyX2MchWP99vYbpWMJfuhOM1/QJVqZHO2GTq7X8d4gA62FWzR25IwV0s03PPXU9lSEGsku",
	"jiFxgVaOEXqpsVt/XuJvtTIpOq1Ppes0nR1UT6hCGfemLyTu52c1LpOgsPVGoXby3EIMHyGO4DRCd4wG",
	"iHPKmu6r6hX6kkYhcmcTzBhC12hpSFi79XXS+yd8hN/8iRfp46rUDt3K/zyiVWOm/IwFCyxQIGLmOZ7E",
	"vckPlFcmnVABo1YEiTliIRTQO+Bqbnt2KXNoqFQhaUvnlybGtGm/2L6r4O/BswP3lhV44KS9DfLuitl7",
	"uzcL72/+8+b2Nwmi25urobLzbi8vzV+jwfXtN91O/ek5CbSl3TgafBmOJ4NRY5vSPszblvbkWdHmzP5+",
	"fX1/MzzP26JuC/XzaHjxZfA9pcXlcHT929lo8P3+7uJsoju8uJ/89/fz/z5X0mjeKNL7iyZCS0t2z/ZB",
	"kKkG1FqQHTWEXHK9qypCWmHc7aEEQ21C/LNAhONphDJlh4Zhh2dO/LbYngtedJXXvBsLcoI9IavKjD7/",
	"Ce9HxCK43jIpY0IfEBkhvqKE+wJq0qT9LmRDD8BWmCH+XR96b5T9OWOILyq65AFd+TJaHhD57g+gc23i",
	"Ve4ScCNLTnqYAOf7StrIhLvea9bGgXe/2oyUI3a2wkry3BzR2cSTYr7jJtvOflnyDa1dFi6j7fIevZ8d",
	"I869haYijIgYhlXJ8u2oFUEuRloNtXvRr5m4nsCw6Q7eN9rZfr93m9r13TSlpPRhRAIa+iKRC4Tni6Zp",
	"Fv6UHbNT3uSglk3Lrp67fBJ4i0dHaI5I6M8GQuFdu5joUmcxttj7S9MeHTbLEj4X6+bkQpn+h/7EeMQw",
	"DT1BSQX5hkzkiISXDP0ZIxKsG78jbT7h4QbXWS6tzxA7g6UnPf6ERbAYa3PNk4rVLm/VxE39eMpHP8rf",
	"0wleDZWAokigymmPJVq0FFIYi8XPit4RfcocN8L/Umu0rZOS+1GZj72+/K1vH0gFpvSVsYdVWaLemfw/",
	"5kIv+EDKP9RRcWtemb4Y4kJ3qA217AT0EF9fVQ0+HRIIKBEwEOlq0aMrRL6efe4ZYvcWQqz4p37/6enp",
	"VD5bwOkpZfN+SAPez+TN2RfBaDCegLO7YS+zD9L7VQfyEYEr3PvU++X0p9O/91QsfqHm2Zf/meuU+WRy",
	"kiG9L0iMKBU9KQfa4FUv/PzTT3b8xkKAq1WEdSym/0+uNZkW59qtNZuRpEiTs4d6t/+pOR4vl1B6vHI8",
	"HEjySamSvIBTGgsgFgiYvKET9Y+zuyEw8weQhEAlNwFBAUNcVf7mpz0b9Pu9x+QU/5Bf6sMwNLsdPnqc",
	"6Rb5YoG/FyI6vcicm+hJbktGIhgi1rM6qHcWBGglPl6lzVJqlYSg2LnRCWB4Ybv/M0ZsnfZuGgzDyn7/",
	"2JKrzZIF1AUHZZvGyeuT3j9++kcpPNYzmX6AUAFmNCZhTg8o6lsN8LsR2j/k7HK4ATCKAAzDj5TkmG84",
	"nmV/39CvHgc6V2+PWNgfz9SRqYZ824obQH6hliXCZkVW8mNsGfdDPHfE6t2KqAaEFb86TMQs6r/ELHrt",
	"m9s+lH1OuQMgQ91ATfeS0eX96KoOI+ojwPQM9AuKm3LdTJkpF+pssT7BYrQBW92UdjyaLBCY40dE5JAA",
	"5mAJI12kBVCm6P8IIxyetmaAIRFXC6jhxIzRpfp38sU6nryo/w/D11pZ/bxWAnA4OdUMTqU0z1czj1a8",
	"PVZV0GCBbiXtN11I+RMWC4Or4UVjWLUT9SYYe/Mw2APbXLpB8S/VDW14GJNaLt7bJhqfP3i4NQ8Tim7K",
	"xTjEtG8qE3KTtObV8LLxhW47lm3fkI1cqS2zt1O1NJEweSjaRzm9KLlgyAskfQGeyX9jopd2+XiGGRcg",
	"SZ5SzXIMk8Nz8kt5vY05plu/K54lF3615Jp6rznfdPMGnFMNq3nH7ZGsSp6NVat354PmBK25G1riTIS5",
	"AHSmHE5F0Bqa6/BQPdVNu/dJ91RYuqJ8OeqWp71Y9OEKq7BpNfHNNiDv7YMaxY3HFk7y38u6RPYmPTap",
	"TOSMERFyfCj0ah/1hk/3XEn62minphyAnNMAyz6BoHqdz34IxByxPBPEwsmD/otE6KseUoT0PkOeGyO0",
	"pI/IkqcsCQ5LTP1vZ95ydySnLCWql/4j9EgfEICAr1Cg7tjMvLQtIyI6N4fl3fbxhWKK2QI2JEVcfKbh",
	"ukIMnj8+PT19nFG2/BizSG1e6kSklAONNlbr8lEcGzevrwdjpRltDTs1RRWrzMZ0lonKTob5rqr4Z7qo",
	"1GWGe/ySsvOYMUSEHPHeFFsmf+A49Zql4dbClMDULUtfkLg9i8WiSo8VnL2Yo3NKH7BzxU7vFvhjZ4Kp",
	"Ezy+e+QzMBuezgffzZXA7u3aOYNE+NPFGAoxQ4H47r7HqlPV0In1X0rXq8C2QyENiQqnAsNGkMFG2erR",
	"iX9qxzGnKLgHnFN9T3Clkvhs27w3S7NwSXKjcm9d7j5Z4md5kzAkz5/+i/lrGL7209y3GpblUxpr2FcO",
	"L+Utp2QAXZhPjRlZ7K+N52yoAEKK9NKAnjFX+VS/ugQtRy0QQL1QTxFgCIYgjJFU/ZgIxAiMAGKMso1Y",
	"bwgJckmcYEaZiYDZ5/lIWAYYJ71V7ApYqlqrR8b6JktPmesb32iztSJviLef3ZFRQKMwz9edg9NU2O0I",
	"nxpDHMAWKDWrjYgZ0YHdEhEqFJw5zPGxdnc9cxDisJvr+uI7cD+84GC6BiuGZvgZ/M3e8ARUWcSPJqcO",
	"haaBpGkU0ScUnigiome4XEXoE/igjyWeLP8U4sO/eSL7to/Dr5mFa7D3uWZynbKRBDANdMrZG3lMOXDW",
	"f8lfpvTaEHif1/dKRVaCr3BPk1OhltpssS30VoLgReSUYXGeYah2d1eMPuIQhSBPsILSPK3YqwJ27BsB",
	"LgsxKez3+TW5PdD6ESYPEr25Oms+6F0VG39enxeRc0gsdqZxNqi73HJhNmP6lGfpAkoYAcsUoAYEqIkl",
	"AFOixr7jx9kXtSTmupYwTeILp5vBTy6mckhaxWU2SQsDS78oDYMpAjpLHghai1a1TH8MC6WNvLqwXAjp",
	"oHluKgEb6BXZtymu2hzBwumporeb7MbSWqm+DrJ8zkHDAQMvQPovMcOvrWDyeX0/Gh4UKjHDvuw5vFed",
	"1x4jG0WL7kdDwNdEwOfd5FBJF6EMKrVGjobNoBXaq0abBJ9+w2KR3E1qT48c2/KzqZxanwiIBRTAHGUG",
	"CX2y5EyJViCiO1TEA1gRdh7LpzVSmfX99xgVEuhZ9FcRxAWe1d9Y0gVnxgIyyRu+JsGCUUJjnrJDWqUq",
	"yir9uNRRLnrBpto0wARwFFASckBnOlUj6SlhRxWL0SMylwj4hGSgW9RwUtAVDrhnmUwe7jBvWH5CWlZo",
	"uRJraWWp40eYcICN1goWkMHAF9uOIqBpkaWWoU6WVH11LM1PsSHB4gY9qSJdExg8eHe8atIMZD/YhEsI",
	"etKmmvo2EEz1K2dIUGBicPVD7r+kL5gMZk9yoorTSI10hbm4pExNxkRvGm2EZz/UXVjv3/v/vkMdqzt7",
	"3TKB8Z48EPpEQI4Cec6eq7vceC6JRPsGEIzHg8yr4AlHEWAoQPgRGebHJoiWN79zXF/A6QoSFPXn+raq",
	"/ov54wYu0Ws/U3LeJ/O5a64kCOrE33wASP4DdDo/BR8CulzGBIv1B7dyz4zpMH5h5RVN7nu+tjtFYrFh",
	"Zu46/JfFhOaTba0hkuW5ZXMrrvdfcPXhhfzM1ayPh/clyxvr1AVMtP9qCOv8Jg6PxhTP3iS4FYTkOpfF",
	"R1UiJzeZnALiiJuTpdAFsgqM4UDSo1p3mAuq3t+Orr15a8OkQW2NSwoCScIslROyGiqTKX2uIrH1VVA4",
	"lE31urZDvCa+0QjxOBIVjuOGm9VhMiGgytHlqaPIkSFN/0U1srH16gQ+SZxLRpeKUrVWrOnXrUEyT3eU",
	"4ueQ+IT2gCnipyIOjNZTNGkfBNTk4QWnwXwkORlnOm/GjT5crRh9RH7T8kw3SGB78FNyO+B46RvSfFc9",
	"+U/XEPSkauk1OV7jM499Xm3trrMem66o8rqlH2ZDRNk5+0Pbas4gJiqMKCiYImAgFJqX/sMZcLdusZaD",
	"bGBD4hlz/en2MmHg6RGK6RrAUH1XueBq7CZhj6E55iIfTamUFDwnlFUIymUE54mUnPGhah4es/5qSWo5",
	"QenxlKgMOdDECVUMZBYzsUDMxkUUWxvSOCZ1VDZLhGolB3RLEpq/I1JbTa+pAWYRnGsFX6a+l7bWQPJa",
	"fcYGOZwmT/ayqrdsVD8bdCxpVtkvnPN2/S7N1ZSAowgFgvp6tu3a9S6t+iVaThEzwQUmEcPxI4rWng8l",
	"LXJfMme/ep9mMOLopJwFXE4awEssAI3FKhZWQeqtxRlGUcjB31QaC0jSWHyZKbr54S1/R/2xjY4N5bfN",
	"Sg69Hos3Be8sDG9ZGpvjQzIyq05v82S4ZtGQ7J3YDSavHtiwFjDYzevB+lS6UrSvcbamQ2vewXVEYQhw",
	"Eg7ewDgIQ7lg5UN2hfVfOuRJhG6BdAqJtBO8zE60a//F3jn82teCy/sv+o+hfVDv7lyrF6TDkzCtTivr",
	"wIEOxbjiJvYm5K1s4IwqqvhWfrp79bPkRyX3cgNNXC1qfjHHQOhMrzTq9nUTNFEd/1ru+DrToXkdhVhI",
	"FbC50wZJCi0zYrOiZ4fURrXoYU7oD9i8Q9gY1SWdMjNQQWuxUtBMDQ9M2nhLZm3aFkbkIEz1crET6VUd",
	"JlEWp/uYiGyVzf3ZBtEPZ3jv2Y7FszR1DfMcijezazWa6s3aPSK1k6htyWpttdMwrN1OgEB648aQ9Sw2",
	"7swQRNSgzs0d/4fSEJ0H0nToS4030HMDf1MbYrc3J+D28vIE3N+dgIvb325OwGhwORqMv/5bU8u4eQQu",
	"+3kSR9FmLJZM0nlYuie5YJAN7Iqsy5LzWA4cKdgnoLbYKcx5Xu6khc4crE6Uyc+uI9Qak7ou+2m9k5Z4",
	"aI3XZ7X3jAmQnCy8/2vF+51YVDo+1MIPbGps9e2KqatV8BUMmrmA+i2169WNIU+2NuSTCbg/kn18KDuv",
	"yhYXUElZR/ZfYjFpn41s5K7pLib0L8Di7vWqJZ9HlWVM1Y0XZ6ciPNc60KsC7biAqjqvkxlPO8FvB/BV",
	"Oi/BbrVB4NRnSUX/Ko9GJRsekdfYhWG4lZ2taoWo3D8620BZpOZXI8q+L8urC1Ne0z5nyDex2n8u81rT",
	"rkL8h+n3Nrfc7zN2RxPcOEVVNuq/CDhvYHBM4PyobA0B555dWfXg+OyLDuzRJLSkdyo3tismcH5EJsVf",
	"kZPGs5BsrF9io7oamjqLv0EJTVN5YLpOzn3ee7OVTAvdoH11g+m6HNAvfCGze3BEe7/mfPRV+7qd2x2w",
	"jIqFPTXbMxDIbh6+pOypVN73RL5q4/Vmbk3E/mbHmz45ePkPle87E/MqV+HYrwOSdpvrAM2awkYBTI+K",
	"l5FwUqsBjmI/z6FbdsnbzuPoRQ3QytQ/16NJC0wsoQh0eXJFhPZrvmAY2Q0lEuJHHMYwUurCjRHnqn9l",
	"tMCE/kV0QPfhhGbQkHzQwdptY/y1SKpSTYVtzNawu8qpJrWRXKGY5BK1pGEcofoyTNeq3eGrMMk56ORT",
	"ZbDIVl0l/SU9qmxidcrvBASU6JJkqpy6uXB4w/TFvRhFKaO6S4fTICkXXMqBp4yn/ssyGUxdtaV02Ac/",
	"d5AbtCerpdDkOFbDAutbLYD6XSBfBgFleoxhJo3e3MOULcKULXFT3H/OQKamvxpArRDjmAtEqi+RuEub",
	"HeIqtr2IdnmOu3Z1kozKDBecl6RluVTiW8MU9UvKyjOsY+IwtNUVHEM8BcOZQmpSTyx3Y4apfqlOck8R",
	"iDkKj//evAyJ9L79jO67cknxaHyyTjximBalD5wcaYeZhultuoC6dZe7BlEDTGxhTU9swpTs9nSXETtV",
	"3ESVJ0kKkpjNIl2+5BT8vl6v1x+vrz+G4YfJh69fPy2Xnzg/HY/H//OHjwqyU3MB+xZjG5Cw65EhErYe",
	"154K221W2smE6LJ1wGuOojvQ3FrkzeUESTaLDXhsJuXVsZALkxrxtpeBahE/rIT/JidpZy4o+DsI4RpM",
	"0YwyBIzEbK0HOpT74ngDfVsF2HicqVZoMco7OEdAX2UvB1oc5GSBeSqWGkhIH5xdwbk5Fuks71s0K+ur",
	"XDnBFSEyFws5NASDhfwoqvqkbr7th5UtQAky+RAGQ5CEAM4kGXTOlQrooFCKJaahb1RT6UlA9UvdnRY7",
	"8p2k+vmKuaBs3d55svrWnjjw6t3CdfKyebZtql8rbBGfYnUGEMeCMmRV65C8Z8W6U9tp4tBRUwQkXlC4",
	"AzW1vUU1SVIMBNXjPPWrbrHf5L7G8tKqdB9lyCdTmJioQ3uXhNEZbhIgvdMNDx8hzdUGrjwXXaoA3f2R",
	"bmwqWB+B35zy59AF7A2myvHUPNg0AFkcVQNvpBo0ujtKXydQx+hG0fTGnk65eLMmjT1wTon30Lsl4k6N",
	"glaZBpLWO425ZVCiGH8C6EpfiBKtjaShEEzXQO2DQBL2pfpUbM0CSYPGf8xH57rK2fR2s+uWEKpMGDm2",
	"puciKtJ0T4zWVC2vqB6loyINeorW9nwDMDPmYh0pgOHlSu2yeTfz5Htq80cv/WrsmAOGZtKaOQXXWNU9",
	"AXYiqRvgL5JT26kcZXo9NodLXeMdRgzBcK0PLPD2mQuachxA9UUXXBJ9o/gYxhHqc7yMI1hbIH5s2suh",
	"jzOv1CyEZYfVfA+FmizoGQWxLlteMrJk860NLWltb+eythjxLz9Jd5tnHCSeEOAUXMdc3ewTIa4qQhPw",
	"9/9fekFvm2Rf22DSMRE4OvySLMEysOTaMkgmzd0lfD4FKWBBaG8vorOUlJgD9BwgFKIN6kwYaCcnhyyr",
	"5ReU4BR1NPhgJeNDrhqmvs0BL/Prf1kOX+T/6rLFdIjO6LZKeTO9uT2l9OH+PAGl6jbZb9yyMAOr/657",
	"Pa2ywprsXO+LA52mV1Ws5nW8JdtdNpCsj5vwquLMxeGE5WhtreMT3ORSuu0F16FR+zrFp9a3OgsamTJH",
	"J9jNLt0PRPuLmA8Eh7xCMNxryuwkj6uW3+dpy3fJ8mR+b5HrKRtbML7m0lzD9ObXph4d37c55HgQHmZu",
	"FlW7R3yjBfwImLbva26LjDXofgur+XgjELhEWu+t+kvHDtTz4zPxNj7xaib8Fm24PNf1REK1MRU35jeL",
	"CaFPFaWCYyKnckOffvi/DhboEIu0o4MkWGE50pQFJvO91nia2Hbv0nQys3uLhpNlYFOGm9T9cyjQnLL1",
	"a+3lNHJKOon8IGEQTxa/HX9VGn+mzVbX3Rz93TaaPRsGclqhFVCW/rKAjyg9EaD2NXgcLIClu8oZUlcR",
	"bIPwD9x+oWKkpU9uIQwNPQtNdG2q/pCKA0nFfh2kPaNfd/2B523qLrDdf1FwfW2D8TsL8B9g3xDspX4V",
	"Gd1d20fHXkrpjQpRdju/cYBi/EMo3qRQ7KJQVXwMXvt+RGncVJR0tMe3PtnThZXZJu/1hGcS0ZxGezni",
	"qRITg8xHnYc7E5bkOdR/SdK2X5tw6+AHu21Cuk+/bnaib5cemw8Prdbere77d6JDFWAwmUgJTVsiJuM+",
	"Vee1mHk386COk8UNLaef3dwDNArzulQ2/tVTfCSjcQNIlMqfIqBJHIIwVucBMBGIERgBxBhlG54JVGXm",
	"Db3zqt4Fj9I9+aVZeQB0UqdY/gLIaMdshmBXnJYaoDmPvRys2MhrxcS3ujzse5vw9c0rLF2hvSsYJ5lE",
	"+1BYVSue9CWamLbnuukPc+mN2NHpjV9xJPBKb3BLDroBp0tYZS5fhIGQvtddtRkl5w5X1fixbfZBZvOx",
	"7gpN2RnmiGBnlCdCHz3qscRT+ZFpRT6APvhgBjuQr431SyuTOFJ/6iT7Qu62jF9/+qW6NQf6zk2GYLBA",
	"pXJJ6aEMMzGg5gV4posW1HjJvlezY5clSK0rne0X+GI6+Y9vF9+x5KioRGua9FrGjeYoMwHH8Xi8UZWf",
	"FvddznVadITJAwpt8CbPcJ8vl8NhVQ2uPJwaCdSL+Sspt1MDnCO438wFkgIk0zm1xeOmVxS73pMKNoBR",
	"NIXBg/uqs17mcX1QlQRRHCKwwGGICHjC4RwpGXaewdWNv6q2h6uwkF0sGi4Olr3TdXLCvxWI+y9anv1o",
	"vqNRpKrOUDZOtMk7xXOlHixG0I0a3EaBFxcD9xHfQqM2OwtvUAik8q+J4FVUgCoswmABOZgiRJL6GxUL",
	"h0GWCvinZVnU5VzJ3oCyYlVBBgmO/M8nye8MzRDjurosoeSjXMeU9aY5UJBjKWE8rZsh7d7E1qkS6DUX",
	"aInJjFauRKrVkOjyNU5jrkMFlnzsswZKZ+UBcDoBAKc0FtoiUN/L0SgliqaSQMuVOo9YRaRJ0ui9bZfY",
	"mXXkfSTUzNI8JXGB5P0X+2ddbVs7zINvgGQG7Lm7I9fgOPZAUia32vWwr3VSzVY066wSNwtM5vVlZCay",
	"2eGLyKTXgUyxnuvQt4SbBsdQG3UsGF6tUJgQcftKL1V1XBRLdRUXta5Kxa3DPCDT2Yktwa7qdcil2oRy",
	"c2jJoKOEl/6LsBOqVTW2YRNdk+3Vow/yLbawBo9pbanUNjnolHExSXiuTalM5bOUVAXT6bRiaxbYUTtv",
	"l0u+NV2X9IsbMfXK5bCK5S1X/1Hk23fxKJfOKauO+mI/avCHueV5R+feU3aUaa1Fp02VoW1vX64aTd3V",
	"omcgxiFYmvovVqWcADwDhCYrcABt6FlaJGqC6iQP5kpH+AsOnZnW+ZJC8pPdlRQi6Ml8RVUADUMOsChe",
	"veyEbaq6zDpXV+7E3Gwomx7eojYDrlg+t146Z5QFvhC4feYIKM5gxNFJY5VZ1FUn4Alymzdyqnd7Xfdm",
	"np8P7iaDC+3Y8zUJFowSGptXK4PZei0tXtv1H76GAY2jsJjQMkUBjDkCWHzg3d3TqL6XFGJN4AvGSIAP",
	"iuYfJLa/f5fM/P5dCuqaxuAJEu26m5Wb6mwM2W0I8HKJQgwFitYe9V25bL9HqO+jdk2VXq5yH0vY3Cyz",
	"3Fwn5DLealNj1BjeJc8PYAw0zcPepR3QCm/NdaHNlYFqzcXb6sE0WUYRrvminUnprEP1EaR7WVQcAbC7",
	"rgdRSrnnvQOivTbty5xH18rSwFdteDQ2HY5AWtToqw7hNZKdvq6MUOvEawKOdeN3J0X7SQ/T1LtGnMtZ",
	"b3egv0tzwYQQyzUyahCUKYsSe6uiHIlNsS+9u2XJlbB37FbCpoe0NNT89VhqsDbDbPkEGWqqry5N+7+k",
	"xmqFkDylKiHiS7+2zDFsTWPU07UOF020Xbe5jvrAix/ZBDsv9q9viHFMyWsTy9HS511hqPSBR00R9ycK",
	"ZNtdwSLHI0t+Y0aBFUNpTT6lmTgUmM8wCk93p8Y0HmycxgxpAwhWKq4zG3S3c+aXlDVaP/cRFXxzyRqW",
	"itttoNRrPb6FCVbYbMl2yQpbfeae/IaAa7hM/jDo2wd9NM30PagHs9lrFsEYZ4f/IunJVzCoTrPWW3WI",
	"ofB+eJ68PSQ39m3PpS95ppFM662yOd/evu2IUpEh3VZZYixhBrgfgvRjwFT0N9dhmpRKRfAsGmJcsUF7",
	"FmY5PKH7YPCuapEXSb79WcSWn+tg1/0sDAEkOT63YXOlwPdfkt+b7XNmpnfJ6HJPwu/oKzvuvdbITOa/",
	"xWUCmpbZa2s35a5/my7Dqb0p6T3waZ+C2hYBeTXdBXMr3M93wd+/isrfoS4xzmcHcDMrhcA1V/zdDydY",
	"X/K3h5x63PqKuxpjSU3PPfcYh5XzthDfXb263PjPQEw0z7Q7CnCYG7ccrh75I8UB6ptcG/WPqnlc6Hbf",
	"KDYaYEeyoT6wSYGg5JIyNRWV+eNPh8/e8avaZ2mkaZElkirdsGJGP/qJpAY/zDZ+b8dVvsZLSOxwMjPd",
	"RtwkMyJ1amumRC9LbRdffD5IMpwJehaf1waxmUEeTcLoxuKuyjHYWiJyUtuV5nM8SnrW+9roWU5Z7XAH",
	"Qaw34X0CuJDYAJaIWTb6pXGMSKhPpzwnqZZWMP39NZfW2prfRZH9vNYK+3DRqyzdjqT28L5Ugwdbmc6q",
	"rGddgYLMo1qsNNIg7xIEPzRSW40Ezdm4TbURh2t/WReJswkdrxAKFnV403aN9xi6etz2/DmMQ0yl0Dz4",
	"O5ZPm9QT2Rm0+ArBh81hleeu7IsnTFWfUGcK7C+aymLBaDxfZI5GppSqZrf6b72RuB9HKDWmOzLN9Oyc",
	"FFAeKHu02I1Z1PvU6zPERe/1j9f/DQAA//8uV96GBWQBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

